Chapter 17. Dynamic functions
==============================
17.1. Diving in
----------------



I want to talk about plural nouns. Also, functions that return other functions,
advanced regular expressions, and generators. Generators are new in Python 2.3.
But first, let's talk about how to make plural nouns.

If you haven't read Chapter 7, Regular Expressions, now would be a good time.
This chapter assumes you understand the basics of regular expressions, and
quickly descends into more advanced uses.

English is a schizophrenic language that borrows from a lot of other languages,
and the rules for making singular nouns into plural nouns are varied and
complex. There are rules, and then there are exceptions to those rules, and
then there are exceptions to the exceptions.

If you grew up in an English-speaking country or learned English in a formal
school setting, you're probably familiar with the basic rules:
   
 1. If a word ends in S, X, or Z, add ES. "Bass" becomes "basses", "fax" becomes
    "faxes", and "waltz" becomes "waltzes".
 2. If a word ends in a noisy H, add ES; if it ends in a silent H, just add S.
    What's a noisy H? One that gets combined with other letters to make a sound
    that you can hear. So "coach" becomes "coaches" and "rash" becomes "rashes
    ", because you can hear the CH and SH sounds when you say them. But "
    cheetah" becomes "cheetahs", because the H is silent.
 3. If a word ends in Y that sounds like I, change the Y to IES; if the Y is
    combined with a vowel to sound like something else, just add S. So "vacancy
    " becomes "vacancies", but "day" becomes "days".
 4. If all else fails, just add S and hope for the best.


(I know, there are a lot of exceptions. "Man" becomes "men" and "woman" becomes
"women", but "human" becomes "humans". "Mouse" becomes "mice" and "louse"
becomes "lice", but "house" becomes "houses". "Knife" becomes "knives" and "
wife" becomes "wives", but "lowlife" becomes "lowlifes". And don't even get me
started on words that are their own plural, like "sheep", "deer", and "haiku".)

Other languages are, of course, completely different.

Let's design a module that pluralizes nouns. Start with just English nouns, and
just these four rules, but keep in mind that you'll inevitably need to add more
rules, and you may eventually need to add more languages.

17.2. plural.py, stage 1
-------------------------



So you're looking at words, which at least in English are strings of
characters. And you have rules that say you need to find different combinations
of characters, and then do different things to them. This sounds like a job for
regular expressions.


Example 17.1. plural1.py
~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    
    def plural(noun):                            
        if re.search('[sxz]$', noun):             (1)
            return re.sub('$', 'es', noun)        (2)
        elif re.search('[^aeioudgkprt]h$', noun):
            return re.sub('$', 'es', noun)       
        elif re.search('[^aeiou]y$', noun):      
            return re.sub('y$', 'ies', noun)     
        else:                                    
            return noun + 's'                    



(1) OK, this is a regular expression, but it uses a syntax you didn't see in
    Chapter 7, Regular Expressions. The square brackets mean "match exactly one
    of these characters". So [sxz] means "s, or x, or z", but only one of them.
    The $ should be familiar; it matches the end of string. So you're checking
    to see if noun ends with s, x, or z.
(2) This re.sub function performs regular expression-based string
    substitutions. Let's look at it in more detail.



Example 17.2. Introducing re.sub
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> import re
    >>> re.search('[abc]', 'Mark')   (1)
    <_sre.SRE_Match object at 0x001C1FA8>
    >>> re.sub('[abc]', 'o', 'Mark') (2)
    'Mork'
    >>> re.sub('[abc]', 'o', 'rock') (3)
    'rook'
    >>> re.sub('[abc]', 'o', 'caps') (4)
    'oops'

(1) Does the string Mark contain a, b, or c? Yes, it contains a.
(2) OK, now find a, b, or c, and replace it with o. Mark becomes Mork.
(3) The same function turns rock into rook.
(4) You might think this would turn caps into oaps, but it doesn't. re.sub
    replaces all of the matches, not just the first one. So this regular
    expression turns caps into oops, because both the c and the a get turned
    into o.



Example 17.3. Back to plural1.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    
    def plural(noun):                            
        if re.search('[sxz]$', noun):            
            return re.sub('$', 'es', noun)        (1)
        elif re.search('[^aeioudgkprt]h$', noun): (2)
            return re.sub('$', 'es', noun)        (3)
        elif re.search('[^aeiou]y$', noun):      
            return re.sub('y$', 'ies', noun)     
        else:                                    
            return noun + 's'                    



(1) Back to the plural function. What are you doing? You're replacing the end
    of string with es. In other words, adding es to the string. You could
    accomplish the same thing with string concatenation, for example noun +
    'es', but I'm using regular expressions for everything, for consistency,
    for reasons that will become clear later in the chapter.
(2) Look closely, this is another new variation. The ^ as the first character
    inside the square brackets means something special: negation. [^abc] means
    "any single character except a, b, or c". So [^aeioudgkprt] means any
    character except a, e, i, o, u, d, g, k, p, r, or t. Then that character
    needs to be followed by h, followed by end of string. You're looking for
    words that end in H where the H can be heard.
(3) Same pattern here: match words that end in Y, where the character before
    the Y is not a, e, i, o, or u. You're looking for words that end in Y that
    sounds like I.



Example 17.4. More on negation regular expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> import re
    >>> re.search('[^aeiou]y$', 'vacancy') (1)
    <_sre.SRE_Match object at 0x001C1FA8>
    >>> re.search('[^aeiou]y$', 'boy')     (2)
    >>> 
    >>> re.search('[^aeiou]y$', 'day')
    >>> 
    >>> re.search('[^aeiou]y$', 'pita')    (3)
    >>> 

(1) vacancy matches this regular expression, because it ends in cy, and c is
    not a, e, i, o, or u.
(2) boy does not match, because it ends in oy, and you specifically said that
    the character before the y could not be o. day does not match, because it
    ends in ay.
(3) pita does not match, because it does not end in y.



Example 17.5. More on re.sub
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> re.sub('y$', 'ies', 'vacancy')              (1)
    'vacancies'
    >>> re.sub('y$', 'ies', 'agency')
    'agencies'
    >>> re.sub('([^aeiou])y$', r'\1ies', 'vacancy') (2)
    'vacancies'

(1) This regular expression turns vacancy into vacancies and agency into
    agencies, which is what you wanted. Note that it would also turn boy into
    boies, but that will never happen in the function because you did that
    re.search first to find out whether you should do this re.sub.
(2) Just in passing, I want to point out that it is possible to combine these
    two regular expressions (one to find out if the rule applies, and another
    to actually apply it) into a single regular expression. Here's what that
    would look like. Most of it should look familiar: you're using a remembered
    group, which you learned in Section 7.6, ??Case study: Parsing Phone
    Numbers??, to remember the character before the y. Then in the substitution
    string, you use a new syntax, \1, which means "hey, that first group you
    remembered? put it here". In this case, you remember the c before the y,
    and then when you do the substitution, you substitute c in place of c, and
    ies in place of y. (If you have more than one remembered group, you can use
    \2 and \3 and so on.)


Regular expression substitutions are extremely powerful, and the \1 syntax
makes them even more powerful. But combining the entire operation into one
regular expression is also much harder to read, and it doesn't directly map to
the way you first described the pluralizing rules. You originally laid out
rules like "if the word ends in S, X, or Z, then add ES". And if you look at
this function, you have two lines of code that say "if the word ends in S, X,
or Z, then add ES". It doesn't get much more direct than that.

17.3. plural.py, stage 2
-------------------------



Now you're going to add a level of abstraction. You started by defining a list
of rules: if this, then do that, otherwise go to the next rule. Let's
temporarily complicate part of the program so you can simplify another part.


Example 17.6. plural2.py
~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    
    def match_sxz(noun):                          
        return re.search('[sxz]$', noun)          
    
    def apply_sxz(noun):                          
        return re.sub('$', 'es', noun)            
    
    def match_h(noun):                            
        return re.search('[^aeioudgkprt]h$', noun)
    
    def apply_h(noun):                            
        return re.sub('$', 'es', noun)            
    
    def match_y(noun):                            
        return re.search('[^aeiou]y$', noun)      
            
    def apply_y(noun):                            
        return re.sub('y$', 'ies', noun)          
    
    def match_default(noun):                      
        return 1                                  
            
    def apply_default(noun):                      
        return noun + 's'                         
    
    rules = ((match_sxz, apply_sxz),
             (match_h, apply_h),
             (match_y, apply_y),
             (match_default, apply_default)
             )                                     (1)
    
    def plural(noun):                             
        for matchesRule, applyRule in rules:       (2)
            if matchesRule(noun):                  (3)
                return applyRule(noun)             (4)



(1) This version looks more complicated (it's certainly longer), but it does
    exactly the same thing: try to match four different rules, in order, and
    apply the appropriate regular expression when a match is found. The
    difference is that each individual match and apply rule is defined in its
    own function, and the functions are then listed in this rules variable,
    which is a tuple of tuples.
(2) Using a for loop, you can pull out the match and apply rules two at a time
    (one match, one apply) from the rules tuple. On the first iteration of the
    for loop, matchesRule will get match_sxz, and applyRule will get apply_sxz.
    On the second iteration (assuming you get that far), matchesRule will be
    assigned match_h, and applyRule will be assigned apply_h.
(3) Remember that everything in Python is an object, including functions. rules
    contains actual functions; not names of functions, but actual functions.
    When they get assigned in the for loop, then matchesRule and applyRule are
    actual functions that you can call. So on the first iteration of the for
    loop, this is equivalent to calling matches_sxz(noun).
(4) On the first iteration of the for loop, this is equivalent to calling
    apply_sxz(noun), and so forth.


If this additional level of abstraction is confusing, try unrolling the
function to see the equivalence. This for loop is equivalent to the following:


Example 17.7. Unrolling the plural function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def plural(noun):
        if match_sxz(noun):
            return apply_sxz(noun)
        if match_h(noun):
            return apply_h(noun)
        if match_y(noun):
            return apply_y(noun)
        if match_default(noun):
            return apply_default(noun)



The benefit here is that that plural function is now simplified. It takes a
list of rules, defined elsewhere, and iterates through them in a generic
fashion. Get a match rule; does it match? Then call the apply rule. The rules
could be defined anywhere, in any way. The plural function doesn't care.

Now, was adding this level of abstraction worth it? Well, not yet. Let's
consider what it would take to add a new rule to the function. Well, in the
previous example, it would require adding an if statement to the plural
function. In this example, it would require adding two functions, match_foo and
apply_foo, and then updating the rules list to specify where in the order the
new match and apply functions should be called relative to the other rules.

This is really just a stepping stone to the next section. Let's move on.

17.4. plural.py, stage 3
-------------------------



Defining separate named functions for each match and apply rule isn't really
necessary. You never call them directly; you define them in the rules list and
call them through there. Let's streamline the rules definition by anonymizing
those functions.


Example 17.8. plural3.py
~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    
    rules = \
      (
        (
         lambda word: re.search('[sxz]$', word),
         lambda word: re.sub('$', 'es', word)
        ),
        (
         lambda word: re.search('[^aeioudgkprt]h$', word),
         lambda word: re.sub('$', 'es', word)
        ),
        (
         lambda word: re.search('[^aeiou]y$', word),
         lambda word: re.sub('y$', 'ies', word)
        ),
        (
         lambda word: re.search('$', word),
         lambda word: re.sub('$', 's', word)
        )
       )                                           (1)
    
    def plural(noun):                             
        for matchesRule, applyRule in rules:       (2)
            if matchesRule(noun):                 
                return applyRule(noun)            



(1) This is the same set of rules as you defined in stage 2. The only
    difference is that instead of defining named functions like match_sxz and
    apply_sxz, you have "inlined" those function definitions directly into the
    rules list itself, using lambda functions.
(2) Note that the plural function hasn't changed at all. It iterates through a
    set of rule functions, checks the first rule, and if it returns a true
    value, calls the second rule and returns the value. Same as above, word for
    word. The only difference is that the rule functions were defined inline,
    anonymously, using lambda functions. But the plural function doesn't care
    how they were defined; it just gets a list of rules and blindly works
    through them.


Now to add a new rule, all you need to do is define the functions directly in
the rules list itself: one match rule, and one apply rule. But defining the
rule functions inline like this makes it very clear that you have some
unnecessary duplication here. You have four pairs of functions, and they all
follow the same pattern. The match function is a single call to re.search, and
the apply function is a single call to re.sub. Let's factor out these
similarities.

17.5. plural.py, stage 4
-------------------------



Let's factor out the duplication in the code so that defining new rules can be
easier.


Example 17.9. plural4.py
~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    
    def buildMatchAndApplyFunctions((pattern, search, replace)):  
        matchFunction = lambda word: re.search(pattern, word)      (1)
        applyFunction = lambda word: re.sub(search, replace, word) (2)
        return (matchFunction, applyFunction)                      (3)



(1) buildMatchAndApplyFunctions is a function that builds other functions
    dynamically. It takes pattern, search and replace (actually it takes a
    tuple, but more on that in a minute), and you can build the match function
    using the lambda syntax to be a function that takes one parameter (word)
    and calls re.search with the pattern that was passed to the
    buildMatchAndApplyFunctions function, and the word that was passed to the
    match function you're building. Whoa.
(2) Building the apply function works the same way. The apply function is a
    function that takes one parameter, and calls re.sub with the search and
    replace parameters that were passed to the buildMatchAndApplyFunctions
    function, and the word that was passed to the apply function you're
    building. This technique of using the values of outside parameters within a
    dynamic function is called closures. You're essentially defining constants
    within the apply function you're building: it takes one parameter (word),
    but it then acts on that plus two other values (search and replace) which
    were set when you defined the apply function.
(3) Finally, the buildMatchAndApplyFunctions function returns a tuple of two
    values: the two functions you just created. The constants you defined
    within those functions (pattern within matchFunction, and search and
    replace within applyFunction) stay with those functions, even after you
    return from buildMatchAndApplyFunctions. That's insanely cool.


If this is incredibly confusing (and it should be, this is weird stuff), it may
become clearer when you see how to use it.


Example 17.10. plural4.py continued
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    patterns = \
      (
        ('[sxz]$', '$', 'es'),
        ('[^aeioudgkprt]h$', '$', 'es'),
        ('(qu|[^aeiou])y$', 'y$', 'ies'),
        ('$', '$', 's')
      )                                                 (1)
    rules = map(buildMatchAndApplyFunctions, patterns)  (2)



(1) Our pluralization rules are now defined as a series of strings (not
    functions). The first string is the regular expression that you would use
    in re.search to see if this rule matches; the second and third are the
    search and replace expressions you would use in re.sub to actually apply
    the rule to turn a noun into its plural.
(2) This line is magic. It takes the list of strings in patterns and turns them
    into a list of functions. How? By mapping the strings to the
    buildMatchAndApplyFunctions function, which just happens to take three
    strings as parameters and return a tuple of two functions. This means that
    rules ends up being exactly the same as the previous example: a list of
    tuples, where each tuple is a pair of functions, where the first function
    is the match function that calls re.search, and the second function is the
    apply function that calls re.sub.


I swear I am not making this up: rules ends up with exactly the same list of
functions as the previous example. Unroll the rules definition, and you'll get
this:


Example 17.11. Unrolling the rules definition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    rules = \
      (
        (
         lambda word: re.search('[sxz]$', word),
         lambda word: re.sub('$', 'es', word)
        ),
        (
         lambda word: re.search('[^aeioudgkprt]h$', word),
         lambda word: re.sub('$', 'es', word)
        ),
        (
         lambda word: re.search('[^aeiou]y$', word),
         lambda word: re.sub('y$', 'ies', word)
        ),
        (
         lambda word: re.search('$', word),
         lambda word: re.sub('$', 's', word)
        )
       )                                          




Example 17.12. plural4.py, finishing up
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def plural(noun):                                  
        for matchesRule, applyRule in rules:            (1)
            if matchesRule(noun):                      
                return applyRule(noun)                 



(1) Since the rules list is the same as the previous example, it should come as
    no surprise that the plural function hasn't changed. Remember, it's
    completely generic; it takes a list of rule functions and calls them in
    order. It doesn't care how the rules are defined. In stage 2, they were
    defined as seperate named functions. In stage 3, they were defined as
    anonymous lambda functions. Now in stage 4, they are built dynamically by
    mapping the buildMatchAndApplyFunctions function onto a list of raw
    strings. Doesn't matter; the plural function still works the same way.


Just in case that wasn't mind-blowing enough, I must confess that there was a
subtlety in the definition of buildMatchAndApplyFunctions that I skipped over.
Let's go back and take another look.


Example 17.13. Another look at buildMatchAndApplyFunctions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def buildMatchAndApplyFunctions((pattern, search, replace)):   (1)
    
(1) Notice the double parentheses? This function doesn't actually take three


    parameters; it actually takes one parameter, a tuple of three elements. But
    the tuple is expanded when the function is called, and the three elements
    of the tuple are each assigned to different variables: pattern, search, and
    replace. Confused yet? Let's see it in action.



Example 17.14. Expanding tuples when calling functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> def foo((a, b, c)):
    ...     print c
    ...     print b
    ...     print a
    >>> parameters = ('apple', 'bear', 'catnap')
    >>> foo(parameters) (1)
    catnap
    bear
    apple

(1) The proper way to call the function foo is with a tuple of three elements.
    When the function is called, the elements are assigned to different local
    variables within foo.


Now let's go back and see why this auto-tuple-expansion trick was necessary.
patterns was a list of tuples, and each tuple had three elements. When you
called map(buildMatchAndApplyFunctions, patterns), that means that
buildMatchAndApplyFunctions is not getting called with three parameters. Using
map to map a single list onto a function always calls the function with a
single parameter: each element of the list. In the case of patterns, each
element of the list is a tuple, so buildMatchAndApplyFunctions always gets
called with the tuple, and you use the auto-tuple-expansion trick in the
definition of buildMatchAndApplyFunctions to assign the elements of that tuple
to named variables that you can work with.

17.6. plural.py, stage 5
-------------------------



You've factored out all the duplicate code and added enough abstractions so
that the pluralization rules are defined in a list of strings. The next logical
step is to take these strings and put them in a separate file, where they can
be maintained separately from the code that uses them.

First, let's create a text file that contains the rules you want. No fancy data
structures, just space- (or tab-)delimited strings in three columns. You'll
call it rules.en; "en" stands for English. These are the rules for pluralizing
English nouns. You could add other rule files for other languages later.


Example 17.15. rules.en
~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    [sxz]$                  $               es
    [^aeioudgkprt]h$        $               es
    [^aeiou]y$              y$              ies
    $                       $               s



Now let's see how you can use this rules file.


Example 17.16. plural5.py
~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    import string                                                                     
    
    def buildRule((pattern, search, replace)):                                        
        return lambda word: re.search(pattern, word) and re.sub(search, replace, word) (1)
    
    def plural(noun, language='en'):                             (2)
        lines = file('rules.%s' % language).readlines()          (3)
        patterns = map(string.split, lines)                      (4)
        rules = map(buildRule, patterns)                         (5)
        for rule in rules:                                      
            result = rule(noun)                                  (6)
            if result: return result                            



(1) You're still using the closures technique here (building a function
    dynamically that uses variables defined outside the function), but now
    you've combined the separate match and apply functions into one. (The
    reason for this change will become clear in the next section.) This will
    let you accomplish the same thing as having two functions, but you'll need
    to call it differently, as you'll see in a minute.
(2) Our plural function now takes an optional second parameter, language, which
    defaults to en.
(3) You use the language parameter to construct a filename, then open the file
    and read the contents into a list. If language is en, then you'll open the
    rules.en file, read the entire thing, break it up by carriage returns, and
    return a list. Each line of the file will be one element in the list.
(4) As you saw, each line in the file really has three values, but they're
    separated by whitespace (tabs or spaces, it makes no difference). Mapping
    the string.split function onto this list will create a new list where each
    element is a tuple of three strings. So a line like [sxz]$ $ es will be
    broken up into the tuple ('[sxz]$', '$', 'es'). This means that patterns
    will end up as a list of tuples, just like you hard-coded it in stage 4.
(5) If patterns is a list of tuples, then rules will be a list of the functions
    created dynamically by each call to buildRule. Calling buildRule(('[sxz]$',
    '$', 'es')) returns a function that takes a single parameter, word. When
    this returned function is called, it will execute re.search('[sxz]$', word)
    and re.sub('$', 'es', word).
(6) Because you're now building a combined match-and-apply function, you need
    to call it differently. Just call the function, and if it returns
    something, then that's the plural; if it returns nothing (None), then the
    rule didn't match and you need to try another rule.


So the improvement here is that you've completely separated the pluralization
rules into an external file. Not only can the file be maintained separately
from the code, but you've set up a naming scheme where the same plural function
can use different rule files, based on the language parameter.

The downside here is that you're reading that file every time you call the
plural function. I thought I could get through this entire book without using
the phrase "left as an exercise for the reader", but here you go: building a
caching mechanism for the language-specific rule files that auto-refreshes
itself if the rule files change between calls is left as an exercise for the
reader. Have fun.

17.7. plural.py, stage 6
-------------------------



Now you're ready to talk about generators.


Example 17.17. plural6.py
~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    import re
    
    def rules(language):                                                                 
        for line in file('rules.%s' % language):                                         
            pattern, search, replace = line.split()                                      
            yield lambda word: re.search(pattern, word) and re.sub(search, replace, word)
    
    def plural(noun, language='en'):      
        for applyRule in rules(language): 
            result = applyRule(noun)      
            if result: return result      



This uses a technique called generators, which I'm not even going to try to
explain until you look at a simpler example first.


Example 17.18. Introducing generators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> def make_counter(x):
    ...     print 'entering make_counter'
    ...     while 1:
    ...         yield x               (1)
    ...         print 'incrementing x'
    ...         x = x + 1
    ...     
    >>> counter = make_counter(2) (2)
    >>> counter                   (3)
    <generator object at 0x001C9C10>
    >>> counter.next()            (4)
    entering make_counter
    2
    >>> counter.next()            (5)
    incrementing x
    3
    >>> counter.next()            (6)
    incrementing x
    4

(1) The presence of the yield keyword in make_counter means that this is not a
    normal function. It is a special kind of function which generates values
    one at a time. You can think of it as a resumable function. Calling it will
    return a generator that can be used to generate successive values of x.
(2) To create an instance of the make_counter generator, just call it like any
    other function. Note that this does not actually execute the function code.
    You can tell this because the first line of make_counter is a print
    statement, but nothing has been printed yet.
(3) The make_counter function returns a generator object.
(4) The first time you call the next() method on the generator object, it
    executes the code in make_counter up to the first yield statement, and then
    returns the value that was yielded. In this case, that will be 2, because
    you originally created the generator by calling make_counter(2).
(5) Repeatedly calling next() on the generator object resumes where you left
    off and continues until you hit the next yield statement. The next line of
    code waiting to be executed is the print statement that prints incrementing
    x, and then after that the x = x + 1 statement that actually increments it.
    Then you loop through the while loop again, and the first thing you do is
    yield x, which returns the current value of x (now 3).
(6) The second time you call counter.next(), you do all the same things again,
    but this time x is now 4. And so forth. Since make_counter sets up an
    infinite loop, you could theoretically do this forever, and it would just
    keep incrementing x and spitting out values. But let's look at more
    productive uses of generators instead.



Example 17.19. Using generators instead of recursion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def fibonacci(max):
        a, b = 0, 1       (1)
        while a < max:
            yield a       (2)
            a, b = b, a+b (3)



(1) The Fibonacci sequence is a sequence of numbers where each number is the
    sum of the two numbers before it. It starts with 0 and 1, goes up slowly at
    first, then more and more rapidly. To start the sequence, you need two
    variables: a starts at 0, and b starts at 1.
(2) a is the current number in the sequence, so yield it.
(3) b is the next number in the sequence, so assign that to a, but also
    calculate the next value (a+b) and assign that to b for later use. Note
    that this happens in parallel; if a is 3 and b is 5, then a, b = b, a+b
    will set a to 5 (the previous value of b) and b to 8 (the sum of the
    previous values of a and b).


So you have a function that spits out successive Fibonacci numbers. Sure, you
could do that with recursion, but this way is easier to read. Also, it works
well with for loops.


Example 17.20. Generators in for loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> for n in fibonacci(1000): (1)
    ...     print n,              (2)
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

(1) You can use a generator like fibonacci in a for loop directly. The for loop
    will create the generator object and successively call the next() method to
    get values to assign to the for loop index variable (n).
(2) Each time through the for loop, n gets a new value from the yield statement
    in fibonacci, and all you do is print it out. Once fibonacci runs out of
    numbers (a gets bigger than max, which in this case is 1000), then the for
    loop exits gracefully.


OK, let's go back to the plural function and see how you're using this.


Example 17.21. Generators that generate dynamic functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def rules(language):                                                                 
        for line in file('rules.%s' % language):                                          (1)
            pattern, search, replace = line.split()                                       (2)
            yield lambda word: re.search(pattern, word) and re.sub(search, replace, word) (3)
    
    def plural(noun, language='en'):      
        for applyRule in rules(language):  (4)
            result = applyRule(noun)      
            if result: return result      



(1) for line in file(...) is a common idiom for reading lines from a file, one
    line at a time. It works because file actually returns a generator whose
    next() method returns the next line of the file. That is so insanely cool,
    I wet myself just thinking about it.
(2) No magic here. Remember that the lines of the rules file have three values
    separated by whitespace, so line.split() returns a tuple of 3 values, and
    you assign those values to 3 local variables.
(3) And then you yield. What do you yield? A function, built dynamically with
    lambda, that is actually a closure (it uses the local variables pattern,
    search, and replace as constants). In other words, rules is a generator
    that spits out rule functions.
(4) Since rules is a generator, you can use it directly in a for loop. The
    first time through the for loop, you will call the rules function, which
    will open the rules file, read the first line out of it, dynamically build
    a function that matches and applies the first rule defined in the rules
    file, and yields the dynamically built function. The second time through
    the for loop, you will pick up where you left off in rules (which was in
    the middle of the for line in file(...) loop), read the second line of the
    rules file, dynamically build another function that matches and applies the
    second rule defined in the rules file, and yields it. And so forth.


What have you gained over stage 5? In stage 5, you read the entire rules file
and built a list of all the possible rules before you even tried the first one.
Now with generators, you can do everything lazily: you open the first and read
the first rule and create a function to try it, but if that works you don't
ever read the rest of the file or create any other functions.

Further reading
   
  * PEP 255 (http://www.python.org/peps/pep-0255.html) defines generators.
  * Python Cookbook (http://www.activestate.com/ASPN/Python/Cookbook/) has
    many more examples of generators (http://www.google.com/search?q=
    generators+cookbook+site:aspn.activestate.com).

17.8. Summary
--------------



You talked about several different advanced techniques in this chapter. Not all
of them are appropriate for every situation.

You should now be comfortable with all of these techniques:
   
  * Performing string substitution with regular expressions.
  * Treating functions as objects, storing them in lists, assigning them to
    variables, and calling them through those variables.
  * Building dynamic functions with lambda.
  * Building closures, dynamic functions that contain surrounding variables
    as constants.
  * Building generators, resumable functions that perform incremental logic
    and return different values each time you call them.


Adding abstractions, building functions dynamically, building closures, and
using generators can all make your code simpler, more readable, and more
flexible. But they can also end up making it more difficult to debug later.
It's up to you to find the right balance between simplicity and power.


Chapter 13. Unit Testing
=========================
13.1. Introduction to Roman numerals
-------------------------------------



In previous chapters, you "dived in" by immediately looking at code and trying
to understand it as quickly as possible. Now that you have some Python under
your belt, you're going to step back and look at the steps that happen before
the code gets written.

In the next few chapters, you're going to write, debug, and optimize a set of
utility functions to convert to and from Roman numerals. You saw the mechanics
of constructing and validating Roman numerals in Section 7.3, ??Case Study:
Roman Numerals??, but now let's step back and consider what it would take to
expand that into a two-way utility.

The rules for Roman numerals lead to a number of interesting observations:
   
 1. There is only one correct way to represent a particular number as Roman
    numerals.
 2. The converse is also true: if a string of characters is a valid Roman
    numeral, it represents only one number (i.e. it can only be read one way).
 3. There is a limited range of numbers that can be expressed as Roman numerals,
    specifically 1 through 3999. (The Romans did have several ways of
    expressing larger numbers, for instance by having a bar over a numeral to
    represent that its normal value should be multiplied by 1000, but you're
    not going to deal with that. For the purposes of this chapter, let's
    stipulate that Roman numerals go from 1 to 3999.)
 4. There is no way to represent 0 in Roman numerals. (Amazingly, the ancient
    Romans had no concept of 0 as a number. Numbers were for counting things
    you had; how can you count what you don't have?)
 5. There is no way to represent negative numbers in Roman numerals.
 6. There is no way to represent fractions or non-integer numbers in Roman
    numerals.


Given all of this, what would you expect out of a set of functions to convert
to and from Roman numerals?


roman.py requirements
   
 1. toRoman should return the Roman numeral representation for all integers 1 to
    3999.
 2. toRoman should fail when given an integer outside the range 1 to 3999.
 3. toRoman should fail when given a non-integer number.
 4. fromRoman should take a valid Roman numeral and return the number that it
    represents.
 5. fromRoman should fail when given an invalid Roman numeral.
 6. If you take a number, convert it to Roman numerals, then convert that back
    to a number, you should end up with the number you started with. So
    fromRoman(toRoman(n)) == n for all n in 1..3999.
 7. toRoman should always return a Roman numeral using uppercase letters.
 8. fromRoman should only accept uppercase Roman numerals (i.e. it should fail
    when given lowercase input).


Further reading
   
  * This site (http://www.wilkiecollins.demon.co.uk/roman/front.htm) has more
    on Roman numerals, including a fascinating history (http://
    www.wilkiecollins.demon.co.uk/roman/intro.htm) of how Romans and other
    civilizations really used them (short answer: haphazardly and
    inconsistently).

13.2. Diving in
----------------



Now that you've completely defined the behavior you expect from your conversion
functions, you're going to do something a little unexpected: you're going to
write a test suite that puts these functions through their paces and makes sure
that they behave the way you want them to. You read that right: you're going to
write code that tests code that you haven't written yet.

This is called unit testing, since the set of two conversion functions can be
written and tested as a unit, separate from any larger program they may become
part of later. Python has a framework for unit testing, the appropriately-named
unittest module.
   
    Note: Do you have unittest?
    unittest is included with Python 2.1 and later. Python 2.0 users can
    download it from pyunit.sourceforge.net (http://pyunit.sourceforge.net/).


Unit testing is an important part of an overall testing-centric development
strategy. If you write unit tests, it is important to write them early
(preferably before writing the code that they test), and to keep them updated
as code and requirements change. Unit testing is not a replacement for
higher-level functional or system testing, but it is important in all phases of
development:
   
  * Before writing code, it forces you to detail your requirements in a
    useful fashion.
  * While writing code, it keeps you from over-coding. When all the test
    cases pass, the function is complete.
  * When refactoring code, it assures you that the new version behaves the
    same way as the old version.
  * When maintaining code, it helps you cover your ass when someone comes
    screaming that your latest change broke their old code. ("But sir, all the
    unit tests passed when I checked it in...")
  * When writing code in a team, it increases confidence that the code you're
    about to commit isn't going to break other peoples' code, because you can
    run their unittests first. (I've seen this sort of thing in code sprints. A
    team breaks up the assignment, everybody takes the specs for their task,
    writes unit tests for it, then shares their unit tests with the rest of the
    team. That way, nobody goes off too far into developing code that won't
    play well with others.)

13.3. Introducing romantest.py
-------------------------------



This is the complete test suite for your Roman numeral conversion functions,
which are yet to be written but will eventually be in roman.py. It is not
immediately obvious how it all fits together; none of these classes or methods
reference any of the others. There are good reasons for this, as you'll see
shortly.


Example 13.1. romantest.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~


If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Unit test for roman.py"""
    
    import roman
    import unittest
    
    class KnownValues(unittest.TestCase):                          
        knownValues = ( (1, 'I'),
                        (2, 'II'),
                        (3, 'III'),
                        (4, 'IV'),
                        (5, 'V'),
                        (6, 'VI'),
                        (7, 'VII'),
                        (8, 'VIII'),
                        (9, 'IX'),
                        (10, 'X'),
                        (50, 'L'),
                        (100, 'C'),
                        (500, 'D'),
                        (1000, 'M'),
                        (31, 'XXXI'),
                        (148, 'CXLVIII'),
                        (294, 'CCXCIV'),
                        (312, 'CCCXII'),
                        (421, 'CDXXI'),
                        (528, 'DXXVIII'),
                        (621, 'DCXXI'),
                        (782, 'DCCLXXXII'),
                        (870, 'DCCCLXX'),
                        (941, 'CMXLI'),
                        (1043, 'MXLIII'),
                        (1110, 'MCX'),
                        (1226, 'MCCXXVI'),
                        (1301, 'MCCCI'),
                        (1485, 'MCDLXXXV'),
                        (1509, 'MDIX'),
                        (1607, 'MDCVII'),
                        (1754, 'MDCCLIV'),
                        (1832, 'MDCCCXXXII'),
                        (1993, 'MCMXCIII'),
                        (2074, 'MMLXXIV'),
                        (2152, 'MMCLII'),
                        (2212, 'MMCCXII'),
                        (2343, 'MMCCCXLIII'),
                        (2499, 'MMCDXCIX'),
                        (2574, 'MMDLXXIV'),
                        (2646, 'MMDCXLVI'),
                        (2723, 'MMDCCXXIII'),
                        (2892, 'MMDCCCXCII'),
                        (2975, 'MMCMLXXV'),
                        (3051, 'MMMLI'),
                        (3185, 'MMMCLXXXV'),
                        (3250, 'MMMCCL'),
                        (3313, 'MMMCCCXIII'),
                        (3408, 'MMMCDVIII'),
                        (3501, 'MMMDI'),
                        (3610, 'MMMDCX'),
                        (3743, 'MMMDCCXLIII'),
                        (3844, 'MMMDCCCXLIV'),
                        (3888, 'MMMDCCCLXXXVIII'),
                        (3940, 'MMMCMXL'),
                        (3999, 'MMMCMXCIX'))                       
    
        def testToRomanKnownValues(self):                          
            """toRoman should give known result with known input"""
            for integer, numeral in self.knownValues:              
                result = roman.toRoman(integer)                    
                self.assertEqual(numeral, result)                  
    
        def testFromRomanKnownValues(self):                          
            """fromRoman should give known result with known input"""
            for integer, numeral in self.knownValues:                
                result = roman.fromRoman(numeral)                    
                self.assertEqual(integer, result)                    
    
    class ToRomanBadInput(unittest.TestCase):                            
        def testTooLarge(self):                                          
            """toRoman should fail with large input"""                   
            self.assertRaises(roman.OutOfRangeError, roman.toRoman, 4000)
    
        def testZero(self):                                              
            """toRoman should fail with 0 input"""                       
            self.assertRaises(roman.OutOfRangeError, roman.toRoman, 0)   
    
        def testNegative(self):                                          
            """toRoman should fail with negative input"""                
            self.assertRaises(roman.OutOfRangeError, roman.toRoman, -1)  
    
        def testNonInteger(self):                                        
            """toRoman should fail with non-integer input"""             
            self.assertRaises(roman.NotIntegerError, roman.toRoman, 0.5) 
    
    class FromRomanBadInput(unittest.TestCase):                                      
        def testTooManyRepeatedNumerals(self):                                       
            """fromRoman should fail with too many repeated numerals"""              
            for s in ('MMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):             
                self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, s)
    
        def testRepeatedPairs(self):                                                 
            """fromRoman should fail with repeated pairs of numerals"""              
            for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):               
                self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, s)
    
        def testMalformedAntecedent(self):                                           
            """fromRoman should fail with malformed antecedents"""                   
            for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
                      'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):                       
                self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, s)
    
    class SanityCheck(unittest.TestCase):        
        def testSanity(self):                    
            """fromRoman(toRoman(n))==n for all n"""
            for integer in range(1, 4000):       
                numeral = roman.toRoman(integer) 
                result = roman.fromRoman(numeral)
                self.assertEqual(integer, result)
    
    class CaseCheck(unittest.TestCase):                   
        def testToRomanCase(self):                        
            """toRoman should always return uppercase"""  
            for integer in range(1, 4000):                
                numeral = roman.toRoman(integer)          
                self.assertEqual(numeral, numeral.upper())
    
        def testFromRomanCase(self):                      
            """fromRoman should only accept uppercase input"""
            for integer in range(1, 4000):                
                numeral = roman.toRoman(integer)          
                roman.fromRoman(numeral.upper())          
                self.assertRaises(roman.InvalidRomanNumeralError,
                                  roman.fromRoman, numeral.lower())
    
    if __name__ == "__main__":
        unittest.main()   



Further reading
   
  * The PyUnit home page (http://pyunit.sourceforge.net/) has an in-depth
    discussion of using the unittest framework (http://pyunit.sourceforge.net/
    pyunit.html), including advanced features not covered in this chapter.
  * The PyUnit FAQ (http://pyunit.sourceforge.net/pyunit.html) explains why
    test cases are stored separately (http://pyunit.sourceforge.net/pyunit.html
    #WHERE) from the code they test.
  * Python Library Reference (http://www.python.org/doc/current/lib/)
    summarizes the unittest (http://www.python.org/doc/current/lib/
    module-unittest.html) module.
  * ExtremeProgramming.org (http://www.extremeprogramming.org/) discusses why
    you should write unit tests (http://www.extremeprogramming.org/rules/
    unittests.html).
  * The Portland Pattern Repository (http://www.c2.com/cgi/wiki) has an
    ongoing discussion of unit tests (http://www.c2.com/cgi/wiki?UnitTests),
    including a standard definition (http://www.c2.com/cgi/wiki?
    StandardDefinitionOfUnitTest), why you should code unit tests first (http:/
    /www.c2.com/cgi/wiki?CodeUnitTestFirst), and several in-depth case studies
    (http://www.c2.com/cgi/wiki?UnitTestTrial).

13.4. Testing for success
--------------------------



The most fundamental part of unit testing is constructing individual test
cases. A test case answers a single question about the code it is testing.

A test case should be able to...
   
  * ...run completely by itself, without any human input. Unit testing is
    about automation.
  * ...determine by itself whether the function it is testing has passed or
    failed, without a human interpreting the results.
  * ...run in isolation, separate from any other test cases (even if they
    test the same functions). Each test case is an island.


Given that, let's build the first test case. You have the following requirement
:
   
 1. toRoman should return the Roman numeral representation for all integers 1 to
    3999.



Example 13.2. testToRomanKnownValues
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class KnownValues(unittest.TestCase):                           (1)
        knownValues = ( (1, 'I'),
                        (2, 'II'),
                        (3, 'III'),
                        (4, 'IV'),
                        (5, 'V'),
                        (6, 'VI'),
                        (7, 'VII'),
                        (8, 'VIII'),
                        (9, 'IX'),
                        (10, 'X'),
                        (50, 'L'),
                        (100, 'C'),
                        (500, 'D'),
                        (1000, 'M'),
                        (31, 'XXXI'),
                        (148, 'CXLVIII'),
                        (294, 'CCXCIV'),
                        (312, 'CCCXII'),
                        (421, 'CDXXI'),
                        (528, 'DXXVIII'),
                        (621, 'DCXXI'),
                        (782, 'DCCLXXXII'),
                        (870, 'DCCCLXX'),
                        (941, 'CMXLI'),
                        (1043, 'MXLIII'),
                        (1110, 'MCX'),
                        (1226, 'MCCXXVI'),
                        (1301, 'MCCCI'),
                        (1485, 'MCDLXXXV'),
                        (1509, 'MDIX'),
                        (1607, 'MDCVII'),
                        (1754, 'MDCCLIV'),
                        (1832, 'MDCCCXXXII'),
                        (1993, 'MCMXCIII'),
                        (2074, 'MMLXXIV'),
                        (2152, 'MMCLII'),
                        (2212, 'MMCCXII'),
                        (2343, 'MMCCCXLIII'),
                        (2499, 'MMCDXCIX'),
                        (2574, 'MMDLXXIV'),
                        (2646, 'MMDCXLVI'),
                        (2723, 'MMDCCXXIII'),
                        (2892, 'MMDCCCXCII'),
                        (2975, 'MMCMLXXV'),
                        (3051, 'MMMLI'),
                        (3185, 'MMMCLXXXV'),
                        (3250, 'MMMCCL'),
                        (3313, 'MMMCCCXIII'),
                        (3408, 'MMMCDVIII'),
                        (3501, 'MMMDI'),
                        (3610, 'MMMDCX'),
                        (3743, 'MMMDCCXLIII'),
                        (3844, 'MMMDCCCXLIV'),
                        (3888, 'MMMDCCCLXXXVIII'),
                        (3940, 'MMMCMXL'),
                        (3999, 'MMMCMXCIX'))                        (2)
    
        def testToRomanKnownValues(self):                           (3)
            """toRoman should give known result with known input"""
            for integer, numeral in self.knownValues:              
                result = roman.toRoman(integer)                     (4) (5)
                self.assertEqual(numeral, result)                   (6)



(1) To write a test case, first subclass the TestCase class of the unittest
    module. This class provides many useful methods which you can use in your
    test case to test specific conditions.
(2) This is a list of integer/numeral pairs that I verified manually. It
    includes the lowest ten numbers, the highest number, every number that
    translates to a single-character Roman numeral, and a random sampling of
    other valid numbers. The point of a unit test is not to test every possible
    input, but to test a representative sample.
(3) Every individual test is its own method, which must take no parameters and
    return no value. If the method exits normally without raising an exception,
    the test is considered passed; if the method raises an exception, the test
    is considered failed.
(4) Here you call the actual toRoman function. (Well, the function hasn't be
    written yet, but once it is, this is the line that will call it.) Notice
    that you have now defined the API for the toRoman function: it must take an
    integer (the number to convert) and return a string (the Roman numeral
    representation). If the API is different than that, this test is considered
    failed.
(5) Also notice that you are not trapping any exceptions when you call toRoman.
    This is intentional. toRoman shouldn't raise an exception when you call it
    with valid input, and these input values are all valid. If toRoman raises
    an exception, this test is considered failed.
(6) Assuming the toRoman function was defined correctly, called correctly,
    completed successfully, and returned a value, the last step is to check
    whether it returned the right value. This is a common question, and the
    TestCase class provides a method, assertEqual, to check whether two values
    are equal. If the result returned from toRoman (result) does not match the
    known value you were expecting (numeral), assertEqual will raise an
    exception and the test will fail. If the two values are equal, assertEqual
    will do nothing. If every value returned from toRoman matches the known
    value you expect, assertEqual never raises an exception, so
    testToRomanKnownValues eventually exits normally, which means toRoman has
    passed this test.

13.5. Testing for failure
--------------------------



It is not enough to test that functions succeed when given good input; you must
also test that they fail when given bad input. And not just any sort of
failure; they must fail in the way you expect.

Remember the other requirements for toRoman:
   
 2. toRoman should fail when given an integer outside the range 1 to 3999.
 3. toRoman should fail when given a non-integer number.


In Python, functions indicate failure by raising exceptions, and the unittest
module provides methods for testing whether a function raises a particular
exception when given bad input.


Example 13.3. Testing bad input to toRoman
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class ToRomanBadInput(unittest.TestCase):                            
        def testTooLarge(self):                                          
            """toRoman should fail with large input"""                   
            self.assertRaises(roman.OutOfRangeError, roman.toRoman, 4000) (1)
    
        def testZero(self):                                              
            """toRoman should fail with 0 input"""                       
            self.assertRaises(roman.OutOfRangeError, roman.toRoman, 0)    (2)
    
        def testNegative(self):                                          
            """toRoman should fail with negative input"""                
            self.assertRaises(roman.OutOfRangeError, roman.toRoman, -1)  
    
        def testNonInteger(self):                                        
            """toRoman should fail with non-integer input"""             
            self.assertRaises(roman.NotIntegerError, roman.toRoman, 0.5)  (3)



(1) The TestCase class of the unittest provides the assertRaises method, which
    takes the following arguments: the exception you're expecting, the function
    you're testing, and the arguments you're passing that function. (If the
    function you're testing takes more than one argument, pass them all to
    assertRaises, in order, and it will pass them right along to the function
    you're testing.) Pay close attention to what you're doing here: instead of
    calling toRoman directly and manually checking that it raises a particular
    exception (by wrapping it in a try...except block), assertRaises has
    encapsulated all of that for us. All you do is give it the exception
    (roman.OutOfRangeError), the function (toRoman), and toRoman's arguments
    (4000), and assertRaises takes care of calling toRoman and checking to make
    sure that it raises roman.OutOfRangeError. (Also note that you're passing
    the toRoman function itself as an argument; you're not calling it, and
    you're not passing the name of it as a string. Have I mentioned recently
    how handy it is that everything in Python is an object, including functions
    and exceptions?)
(2) Along with testing numbers that are too large, you need to test numbers
    that are too small. Remember, Roman numerals cannot express 0 or negative
    numbers, so you have a test case for each of those (testZero and
    testNegative). In testZero, you are testing that toRoman raises a
    roman.OutOfRangeError exception when called with 0; if it does not raise a
    roman.OutOfRangeError (either because it returns an actual value, or
    because it raises some other exception), this test is considered failed.
(3) Requirement #3 specifies that toRoman cannot accept a non-integer number,
    so here you test to make sure that toRoman raises a roman.NotIntegerError
    exception when called with 0.5. If toRoman does not raise a
    roman.NotIntegerError, this test is considered failed.


The next two requirements are similar to the first three, except they apply to
fromRoman instead of toRoman:
   
 4. fromRoman should take a valid Roman numeral and return the number that it
    represents.
 5. fromRoman should fail when given an invalid Roman numeral.


Requirement #4 is handled in the same way as requirement #1, iterating through
a sampling of known values and testing each in turn. Requirement #5 is handled
in the same way as requirements #2 and #3, by testing a series of bad inputs
and making sure fromRoman raises the appropriate exception.


Example 13.4. Testing bad input to fromRoman
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class FromRomanBadInput(unittest.TestCase):                                      
        def testTooManyRepeatedNumerals(self):                                       
            """fromRoman should fail with too many repeated numerals"""              
            for s in ('MMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):             
                self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, s) (1)
    
        def testRepeatedPairs(self):                                                 
            """fromRoman should fail with repeated pairs of numerals"""              
            for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):               
                self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, s)
    
        def testMalformedAntecedent(self):                                           
            """fromRoman should fail with malformed antecedents"""                   
            for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
                      'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):                       
                self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, s)



(1) Not much new to say about these; the pattern is exactly the same as the one
    you used to test bad input to toRoman. I will briefly note that you have
    another exception: roman.InvalidRomanNumeralError. That makes a total of
    three custom exceptions that will need to be defined in roman.py (along
    with roman.OutOfRangeError and roman.NotIntegerError). You'll see how to
    define these custom exceptions when you actually start writing roman.py,
    later in this chapter.

13.6. Testing for sanity
-------------------------



Often, you will find that a unit of code contains a set of reciprocal
functions, usually in the form of conversion functions where one converts A to
B and the other converts B to A. In these cases, it is useful to create a "
sanity check" to make sure that you can convert A to B and back to A without
losing precision, incurring rounding errors, or triggering any other sort of
bug.

Consider this requirement:
   
 6. If you take a number, convert it to Roman numerals, then convert that back
    to a number, you should end up with the number you started with. So
    fromRoman(toRoman(n)) == n for all n in 1..3999.



Example 13.5. Testing toRoman against fromRoman
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class SanityCheck(unittest.TestCase):        
        def testSanity(self):                    
            """fromRoman(toRoman(n))==n for all n"""
            for integer in range(1, 4000):        (1) (2)
                numeral = roman.toRoman(integer) 
                result = roman.fromRoman(numeral)
                self.assertEqual(integer, result) (3)



(1) You've seen the range function before, but here it is called with two
    arguments, which returns a list of integers starting at the first argument
    (1) and counting consecutively up to but not including the second argument
    (4000). Thus, 1..3999, which is the valid range for converting to Roman
    numerals.
(2) I just wanted to mention in passing that integer is not a keyword in Python
    ; here it's just a variable name like any other.
(3) The actual testing logic here is straightforward: take a number (integer),
    convert it to a Roman numeral (numeral), then convert it back to a number
    (result) and make sure you end up with the same number you started with. If
    not, assertEqual will raise an exception and the test will immediately be
    considered failed. If all the numbers match, assertEqual will always return
    silently, the entire testSanity method will eventually return silently, and
    the test will be considered passed.


The last two requirements are different from the others because they seem both
arbitrary and trivial:
   
 7. toRoman should always return a Roman numeral using uppercase letters.
 8. fromRoman should only accept uppercase Roman numerals (i.e. it should fail
    when given lowercase input).


In fact, they are somewhat arbitrary. You could, for instance, have stipulated
that fromRoman accept lowercase and mixed case input. But they are not
completely arbitrary; if toRoman is always returning uppercase output, then
fromRoman must at least accept uppercase input, or the "sanity check"
(requirement #6) would fail. The fact that it only accepts uppercase input is
arbitrary, but as any systems integrator will tell you, case always matters, so
it's worth specifying the behavior up front. And if it's worth specifying, it's
worth testing.


Example 13.6. Testing for case
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class CaseCheck(unittest.TestCase):                   
        def testToRomanCase(self):                        
            """toRoman should always return uppercase"""  
            for integer in range(1, 4000):                
                numeral = roman.toRoman(integer)          
                self.assertEqual(numeral, numeral.upper())         (1)
    
        def testFromRomanCase(self):                      
            """fromRoman should only accept uppercase input"""
            for integer in range(1, 4000):                
                numeral = roman.toRoman(integer)          
                roman.fromRoman(numeral.upper())                   (2) (3)
                self.assertRaises(roman.InvalidRomanNumeralError,
                                  roman.fromRoman, numeral.lower())   (4)



(1) The most interesting thing about this test case is all the things it
    doesn't test. It doesn't test that the value returned from toRoman is right
    or even consistent; those questions are answered by separate test cases.
    You have a whole test case just to test for uppercase-ness. You might be
    tempted to combine this with the sanity check, since both run through the
    entire range of values and call toRoman.[6] But that would violate one of
    the fundamental rules: each test case should answer only a single question.
    Imagine that you combined this case check with the sanity check, and then
    that test case failed. You would need to do further analysis to figure out
    which part of the test case failed to determine what the problem was. If
    you need to analyze the results of your unit testing just to figure out
    what they mean, it's a sure sign that you've mis-designed your test cases.
(2) There's a similar lesson to be learned here: even though "you know" that
    toRoman always returns uppercase, you are explicitly converting its return
    value to uppercase here to test that fromRoman accepts uppercase input.
    Why? Because the fact that toRoman always returns uppercase is an
    independent requirement. If you changed that requirement so that, for
    instance, it always returned lowercase, the testToRomanCase test case would
    need to change, but this test case would still work. This was another of
    the fundamental rules: each test case must be able to work in isolation
    from any of the others. Every test case is an island.
(3) Note that you're not assigning the return value of fromRoman to anything.
    This is legal syntax in Python; if a function returns a value but nobody's
    listening, Python just throws away the return value. In this case, that's
    what you want. This test case doesn't test anything about the return value;
    it just tests that fromRoman accepts the uppercase input without raising an
    exception.
(4) This is a complicated line, but it's very similar to what you did in the
    ToRomanBadInput and FromRomanBadInput tests. You are testing to make sure
    that calling a particular function (roman.fromRoman) with a particular
    value (numeral.lower(), the lowercase version of the current Roman numeral
    in the loop) raises a particular exception
    (roman.InvalidRomanNumeralError). If it does (each time through the loop),
    the test passes; if even one time it does something else (like raises a
    different exception, or returning a value without raising an exception at
    all), the test fails.


In the next chapter, you'll see how to write code that passes these tests.

------------

[6] "I can resist everything except temptation." --Oscar Wilde


Chapter 5. Objects and Object-Orientation
==========================================

This chapter, and pretty much every chapter after this, deals with
object-oriented Python programming.

5.1. Diving In
---------------



Here is a complete, working Python program. Read the doc strings of the module,
the classes, and the functions to get an overview of what this program does and
how it works. As usual, don't worry about the stuff you don't understand;
that's what the rest of the chapter is for.


Example 5.1. fileinfo.py
~~~~~~~~~~~~~~~~~~~~~~~~~


If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Framework for getting filetype-specific metadata.
    
    Instantiate appropriate class with filename.  Returned object acts like a
    dictionary, with key-value pairs for each piece of metadata.
        import fileinfo
        info = fileinfo.MP3FileInfo("/music/ap/mahadeva.mp3")
        print "\\n".join(["%s=%s" % (k, v) for k, v in info.items()])
    
    Or use listDirectory function to get info on all files in a directory.
        for info in fileinfo.listDirectory("/music/ap/", [".mp3"]):
            ...
    
    Framework can be extended by adding classes for particular file types, e.g.
    HTMLFileInfo, MPGFileInfo, DOCFileInfo.  Each class is completely responsible for
    parsing its files appropriately; see MP3FileInfo for example.
    """
    import os
    import sys
    from UserDict import UserDict
    
    def stripnulls(data):
        "strip whitespace and nulls"
        return data.replace("\00", "").strip()
    
    class FileInfo(UserDict):
        "store file metadata"
        def __init__(self, filename=None):
            UserDict.__init__(self)
            self["name"] = filename
    
    class MP3FileInfo(FileInfo):
        "store ID3v1.0 MP3 tags"
        tagDataMap = {"title"   : (  3,  33, stripnulls),
                      "artist"  : ( 33,  63, stripnulls),
                      "album"   : ( 63,  93, stripnulls),
                      "year"    : ( 93,  97, stripnulls),
                      "comment" : ( 97, 126, stripnulls),
                      "genre"   : (127, 128, ord)}
    
        def __parse(self, filename):
            "parse ID3v1.0 tags from MP3 file"
            self.clear()
            try:                               
                fsock = open(filename, "rb", 0)
                try:                           
                    fsock.seek(-128, 2)        
                    tagdata = fsock.read(128)  
                finally:                       
                    fsock.close()              
                if tagdata[:3] == "TAG":
                    for tag, (start, end, parseFunc) in self.tagDataMap.items():
                        self[tag] = parseFunc(tagdata[start:end])               
            except IOError:                    
                pass                           
    
        def __setitem__(self, key, item):
            if key == "name" and item:
                self.__parse(item)
            FileInfo.__setitem__(self, key, item)
    
    def listDirectory(directory, fileExtList):                                        
        "get list of file info objects for files of particular extensions"
        fileList = [os.path.normcase(f)
                    for f in os.listdir(directory)]           
        fileList = [os.path.join(directory, f) 
                   for f in fileList
                    if os.path.splitext(f)[1] in fileExtList] 
        def getFileInfoClass(filename, module=sys.modules[FileInfo.__module__]):      
            "get file info class from filename extension"                             
            subclass = "%sFileInfo" % os.path.splitext(filename)[1].upper()[1:]       
            return hasattr(module, subclass) and getattr(module, subclass) or FileInfo
        return [getFileInfoClass(f)(f) for f in fileList]                             
    
    if __name__ == "__main__":
        for info in listDirectory("/music/_singles/", [".mp3"]): (1)
            print "\n".join(["%s=%s" % (k, v) for k, v in info.items()])
            print



(1) This program's output depends on the files on your hard drive. To get
    meaningful output, you'll need to change the directory path to point to a
    directory of MP3 files on your own machine.


This is the output I got on my machine. Your output will be different, unless,
by some startling coincidence, you share my exact taste in music.


::

    album=
    artist=Ghost in the Machine
    title=A Time Long Forgotten (Concept
    genre=31
    name=/music/_singles/a_time_long_forgotten_con.mp3
    year=1999
    comment=http://mp3.com/ghostmachine
    
    album=Rave Mix
    artist=***DJ MARY-JANE***
    title=HELLRAISER****Trance from Hell
    genre=31
    name=/music/_singles/hellraiser.mp3
    year=2000
    comment=http://mp3.com/DJMARYJANE
    
    album=Rave Mix
    artist=***DJ MARY-JANE***
    title=KAIRO****THE BEST GOA
    genre=31
    name=/music/_singles/kairo.mp3
    year=2000
    comment=http://mp3.com/DJMARYJANE
    
    album=Journeys
    artist=Masters of Balance
    title=Long Way Home
    genre=31
    name=/music/_singles/long_way_home1.mp3
    year=2000
    comment=http://mp3.com/MastersofBalan
    
    album=
    artist=The Cynic Project
    title=Sidewinder
    genre=18
    name=/music/_singles/sidewinder.mp3
    year=2000
    comment=http://mp3.com/cynicproject
    
    album=Digitosis@128k
    artist=VXpanded
    title=Spinning
    genre=255
    name=/music/_singles/spinning.mp3
    year=2000
    comment=http://mp3.com/artists/95/vxp



5.2. Importing Modules Using from module import
------------------------------------------------



Python has two ways of importing modules. Both are useful, and you should know
when to use each. One way, import module, you've already seen in Section 2.4,
??Everything Is an Object??. The other way accomplishes the same thing, but it
has subtle and important differences.

Here is the basic from module import syntax:


::

    from UserDict import UserDict
    
This is similar to the import module syntax that you know and love, but with an


important difference: the attributes and methods of the imported module types
are imported directly into the local namespace, so they are available directly,
without qualification by module name. You can import individual items or use
from module import * to import everything.
   
    Note: Python vs. Perl: from module import
    from module import * in Python is like use module in Perl; import module in
    Python is like require module in Perl.

    Note: Python vs. Java: from module import
    from module import * in Python is like import module.* in Java; import
    module in Python is like import module in Java.



Example 5.2. import module vs. from module import
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> import types
    >>> types.FunctionType             (1)
    <type 'function'>
    >>> FunctionType                   (2)
    Traceback (innermost last):
      File "<interactive input>", line 1, in ?
    NameError: There is no variable named 'FunctionType'
    >>> from types import FunctionType (3)
    >>> FunctionType                   (4)
    <type 'function'>

(1) The types module contains no methods; it just has attributes for each
    Python object type. Note that the attribute, FunctionType, must be
    qualified by the module name, types.
(2) FunctionType by itself has not been defined in this namespace; it exists
    only in the context of types.
(3) This syntax imports the attribute FunctionType from the types module
    directly into the local namespace.
(4) Now FunctionType can be accessed directly, without reference to types.


When should you use from module import?
   
  * If you will be accessing attributes and methods often and don't want to
    type the module name over and over, use from module import.
  * If you want to selectively import some attributes and methods but not
    others, use from module import.
  * If the module contains attributes or functions with the same name as ones
    in your module, you must use import module to avoid name conflicts.


Other than that, it's just a matter of style, and you will see Python code
written both ways.
   
    Caution:
    Use from module import * sparingly, because it makes it difficult to
    determine where a particular function or attribute came from, and that
    makes debugging and refactoring more difficult.


Further Reading on Module Importing Techniques
   
  * eff-bot (http://www.effbot.org/guides/) has more to say on import module
    vs. from module import (http://www.effbot.org/guides/import-confusion.htm).
  * Python Tutorial (http://www.python.org/doc/current/tut/tut.html)
    discusses advanced import techniques, including from module import * (http:
    //www.python.org/doc/current/tut/node8.html#SECTION008410000000000000000).

5.3. Defining Classes
----------------------



Python is fully object-oriented: you can define your own classes, inherit from
your own or built-in classes, and instantiate the classes you've defined.

Defining a class in Python is simple. As with functions, there is no separate
interface definition. Just define the class and start coding. A Python class
starts with the reserved word class, followed by the class name. Technically,
that's all that's required, since a class doesn't need to inherit from any
other class.


Example 5.3. The Simplest Python Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class Loaf: (1)
        pass    (2) (3)



(1) The name of this class is Loaf, and it doesn't inherit from any other
    class. Class names are usually capitalized, EachWordLikeThis, but this is
    only a convention, not a requirement.
(2) This class doesn't define any methods or attributes, but syntactically,
    there needs to be something in the definition, so you use pass. This is a
    Python reserved word that just means "move along, nothing to see here".
    It's a statement that does nothing, and it's a good placeholder when you're
    stubbing out functions or classes.
(3) You probably guessed this, but everything in a class is indented, just like
    the code within a function, if statement, for loop, and so forth. The first
    thing not indented is not in the class.

    Note: Python vs. Java: pass
    The pass statement in Python is like an empty set of braces ({}) in Java or
    C.


Of course, realistically, most classes will be inherited from other classes,
and they will define their own class methods and attributes. But as you've just
seen, there is nothing that a class absolutely must have, other than a name. In
particular, C++ programmers may find it odd that Python classes don't have
explicit constructors and destructors. Python classes do have something similar
to a constructor: the __init__ method.


Example 5.4. Defining the FileInfo Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    from UserDict import UserDict
    
    class FileInfo(UserDict): (1)



(1) In Python, the ancestor of a class is simply listed in parentheses
    immediately after the class name. So the FileInfo class is inherited from
    the UserDict class (which was imported from the UserDict module). UserDict
    is a class that acts like a dictionary, allowing you to essentially
    subclass the dictionary datatype and add your own behavior. (There are
    similar classes UserList and UserString which allow you to subclass lists
    and strings.) There is a bit of black magic behind this, which you will
    demystify later in this chapter when you explore the UserDict class in more
    depth.

    Note: Python vs. Java: Ancestors
    In Python, the ancestor of a class is simply listed in parentheses
    immediately after the class name. There is no special keyword like extends
    in Java.


Python supports multiple inheritance. In the parentheses following the class
name, you can list as many ancestor classes as you like, separated by commas.

5.3.1. Initializing and Coding Classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



This example shows the initialization of the FileInfo class using the __init__
method.


Example 5.5. Initializing the FileInfo Class
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



.. sourcecode:: python

    class FileInfo(UserDict):
        "store file metadata"              (1)
        def __init__(self, filename=None): (2) (3) (4)
    
(1) Classes can (and should) have doc strings too, just like modules and


    functions.
(2) __init__ is called immediately after an instance of the class is created.
    It would be tempting but incorrect to call this the constructor of the
    class. It's tempting, because it looks like a constructor (by convention,
    __init__ is the first method defined for the class), acts like one (it's
    the first piece of code executed in a newly created instance of the class),
    and even sounds like one ("init" certainly suggests a constructor-ish
    nature). Incorrect, because the object has already been constructed by the
    time __init__ is called, and you already have a valid reference to the new
    instance of the class. But __init__ is the closest thing you're going to
    get to a constructor in Python, and it fills much the same role.
(3) The first argument of every class method, including __init__, is always a
    reference to the current instance of the class. By convention, this
    argument is always named self. In the __init__ method, self refers to the
    newly created object; in other class methods, it refers to the instance
    whose method was called. Although you need to specify self explicitly when
    defining the method, you do not specify it when calling the method; Python
    will add it for you automatically.
(4) __init__ methods can take any number of arguments, and just like functions,
    the arguments can be defined with default values, making them optional to
    the caller. In this case, filename has a default value of None, which is
    the Python null value.

    Note: Python vs. Java: self
    By convention, the first argument of any Python class method (the reference
    to the current instance) is called self. This argument fills the role of
    the reserved word this in C++ or Java, but self is not a reserved word in
    Python, merely a naming convention. Nonetheless, please don't call it
    anything but self; this is a very strong convention.



Example 5.6. Coding the FileInfo Class
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



.. sourcecode:: python

    class FileInfo(UserDict):
        "store file metadata"
        def __init__(self, filename=None):
            UserDict.__init__(self)        (1)
            self["name"] = filename        (2)
                                           (3)



(1) Some pseudo-object-oriented languages like Powerbuilder have a concept of "
    extending" constructors and other events, where the ancestor's method is
    called automatically before the descendant's method is executed. Python
    does not do this; you must always explicitly call the appropriate method in
    the ancestor class.
(2) I told you that this class acts like a dictionary, and here is the first
    sign of it. You're assigning the argument filename as the value of this
    object's name key.
(3) Note that the __init__ method never returns a value.

5.3.2. Knowing When to Use self and __init__
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



When defining your class methods, you must explicitly list self as the first
argument for each method, including __init__. When you call a method of an
ancestor class from within your class, you must include the self argument. But
when you call your class method from outside, you do not specify anything for
the self argument; you skip it entirely, and Python automatically adds the
instance reference for you. I am aware that this is confusing at first; it's
not really inconsistent, but it may appear inconsistent because it relies on a
distinction (between bound and unbound methods) that you don't know about yet.

Whew. I realize that's a lot to absorb, but you'll get the hang of it. All
Python classes work the same way, so once you learn one, you've learned them
all. If you forget everything else, remember this one thing, because I promise
it will trip you up:
   
    Note: __init__ Methods
    __init__ methods are optional, but when you define one, you must remember
    to explicitly call the ancestor's __init__ method (if it defines one). This
    is more generally true: whenever a descendant wants to extend the behavior
    of the ancestor, the descendant method must explicitly call the ancestor
    method at the proper time, with the proper arguments.


Further Reading on Python Classes
   
  * Learning to Program (http://www.freenetpages.co.uk/hp/alan.gauld/) has a
    gentler introduction to classes (http://www.freenetpages.co.uk/hp/
    alan.gauld/tutclass.htm).
  * How to Think Like a Computer Scientist (http://www.ibiblio.org/obp/
    thinkCSpy/) shows how to use classes to model compound datatypes (http://
    www.ibiblio.org/obp/thinkCSpy/chap12.htm).
  * Python Tutorial (http://www.python.org/doc/current/tut/tut.html) has an
    in-depth look at classes, namespaces, and inheritance (http://
    www.python.org/doc/current/tut/node11.html).
  * Python Knowledge Base (http://www.faqts.com/knowledge-base/index.phtml/
    fid/199/) answers common questions about classes (http://www.faqts.com/
    knowledge-base/index.phtml/fid/242).

5.4. Instantiating Classes
---------------------------



Instantiating classes in Python is straightforward. To instantiate a class,
simply call the class as if it were a function, passing the arguments that the
__init__ method defines. The return value will be the newly created object.


Example 5.7. Creating a FileInfo Instance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> import fileinfo
    >>> f = fileinfo.FileInfo("/music/_singles/kairo.mp3") (1)
    >>> f.__class__                                        (2)
    <class fileinfo.FileInfo at 010EC204>
    >>> f.__doc__                                          (3)
    'store file metadata'
    >>> f                                                  (4)
    {'name': '/music/_singles/kairo.mp3'}

(1) You are creating an instance of the FileInfo class (defined in the fileinfo
    module) and assigning the newly created instance to the variable f. You are
    passing one parameter, /music/_singles/kairo.mp3, which will end up as the
    filename argument in FileInfo's __init__ method.
(2) Every class instance has a built-in attribute, __class__, which is the
    object's class. (Note that the representation of this includes the physical
    address of the instance on my machine; your representation will be
    different.) Java programmers may be familiar with the Class class, which
    contains methods like getName and getSuperclass to get metadata information
    about an object. In Python, this kind of metadata is available directly on
    the object itself through attributes like __class__, __name__, and
    __bases__.
(3) You can access the instance's doc string just as with a function or a
    module. All instances of a class share the same doc string.
(4) Remember when the __init__ method assigned its filename argument to self
    ["name"]? Well, here's the result. The arguments you pass when you create
    the class instance get sent right along to the __init__ method (along with
    the object reference, self, which Python adds for free).

    Note: Python vs. Java: Instantiating Classes
    In Python, simply call a class as if it were a function to create a new
    instance of the class. There is no explicit new operator like C++ or Java.

5.4.1. Garbage Collection
~~~~~~~~~~~~~~~~~~~~~~~~~~



If creating new instances is easy, destroying them is even easier. In general,
there is no need to explicitly free instances, because they are freed
automatically when the variables assigned to them go out of scope. Memory leaks
are rare in Python.


Example 5.8. Trying to Implement a Memory Leak
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



::

    >>> def leakmem():
    ...     f = fileinfo.FileInfo('/music/_singles/kairo.mp3') (1)
    ...     
    >>> for i in range(100):
    ...     leakmem()                                          (2)

(1) Every time the leakmem function is called, you are creating an instance of
    FileInfo and assigning it to the variable f, which is a local variable
    within the function. Then the function ends without ever freeing f, so you
    would expect a memory leak, but you would be wrong. When the function ends,
    the local variable f goes out of scope. At this point, there are no longer
    any references to the newly created instance of FileInfo (since you never
    assigned it to anything other than f), so Python destroys the instance for
    us.
(2) No matter how many times you call the leakmem function, it will never leak
    memory, because every time, Python will destroy the newly created FileInfo
    class before returning from leakmem.


The technical term for this form of garbage collection is "reference counting".
Python keeps a list of references to every instance created. In the above
example, there was only one reference to the FileInfo instance: the local
variable f. When the function ends, the variable f goes out of scope, so the
reference count drops to 0, and Python destroys the instance automatically.

In previous versions of Python, there were situations where reference counting
failed, and Python couldn't clean up after you. If you created two instances
that referenced each other (for instance, a doubly-linked list, where each node
has a pointer to the previous and next node in the list), neither instance
would ever be destroyed automatically because Python (correctly) believed that
there is always a reference to each instance. Python 2.0 has an additional form
of garbage collection called "mark-and-sweep" which is smart enough to notice
this virtual gridlock and clean up circular references correctly.

As a former philosophy major, it disturbs me to think that things disappear
when no one is looking at them, but that's exactly what happens in Python. In
general, you can simply forget about memory management and let Python clean up
after you.

Further Reading on Garbage Collection
   
  * Python Library Reference (http://www.python.org/doc/current/lib/)
    summarizes built-in attributes like __class__ (http://www.python.org/doc/
    current/lib/specialattrs.html).
  * Python Library Reference (http://www.python.org/doc/current/lib/)
    documents the gc module (http://www.python.org/doc/current/lib/
    module-gc.html), which gives you low-level control over Python's garbage
    collection.

5.5. Exploring UserDict: A Wrapper Class
-----------------------------------------



As you've seen, FileInfo is a class that acts like a dictionary. To explore
this further, let's look at the UserDict class in the UserDict module, which is
the ancestor of the FileInfo class. This is nothing special; the class is
written in Python and stored in a .py file, just like any other Python code. In
particular, it's stored in the lib directory in your Python installation.
   
    Tip:
    In the ActivePython IDE on Windows, you can quickly open any module in your
    library path by selecting File->Locate... (Ctrl-L).



Example 5.9. Defining the UserDict Class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class UserDict:                                (1)
        def __init__(self, dict=None):             (2)
            self.data = {}                         (3)
            if dict is not None: self.update(dict) (4) (5)



(1) Note that UserDict is a base class, not inherited from any other class.
(2) This is the __init__ method that you overrode in the FileInfo class. Note
    that the argument list in this ancestor class is different than the
    descendant. That's okay; each subclass can have its own set of arguments,
    as long as it calls the ancestor with the correct arguments. Here the
    ancestor class has a way to define initial values (by passing a dictionary
    in the dict argument) which the FileInfo does not use.
(3) Python supports data attributes (called "instance variables" in Java and
    Powerbuilder, and "member variables" in C++). Data attributes are pieces of
    data held by a specific instance of a class. In this case, each instance of
    UserDict will have a data attribute data. To reference this attribute from
    code outside the class, you qualify it with the instance name,
    instance.data, in the same way that you qualify a function with its module
    name. To reference a data attribute from within the class, you use self as
    the qualifier. By convention, all data attributes are initialized to
    reasonable values in the __init__ method. However, this is not required,
    since data attributes, like local variables, spring into existence when
    they are first assigned a value.
(4) The update method is a dictionary duplicator: it copies all the keys and
    values from one dictionary to another. This does not clear the target
    dictionary first; if the target dictionary already has some keys, the ones
    from the source dictionary will be overwritten, but others will be left
    untouched. Think of update as a merge function, not a copy function.
(5) This is a syntax you may not have seen before (I haven't used it in the
    examples in this book). It's an if statement, but instead of having an
    indented block starting on the next line, there is just a single statement
    on the same line, after the colon. This is perfectly legal syntax, which is
    just a shortcut you can use when you have only one statement in a block.
    (It's like specifying a single statement without braces in C++.) You can
    use this syntax, or you can have indented code on subsequent lines, but you
    can't do both for the same block.

    Note: Python vs. Java: Function Overloading
    Java and Powerbuilder support function overloading by argument list, i.e.
    one class can have multiple methods with the same name but a different
    number of arguments, or arguments of different types. Other languages (most
    notably PL/SQL) even support function overloading by argument name; i.e.
    one class can have multiple methods with the same name and the same number
    of arguments of the same type but different argument names. Python supports
    neither of these; it has no form of function overloading whatsoever.
    Methods are defined solely by their name, and there can be only one method
    per class with a given name. So if a descendant class has an __init__
    method, it always overrides the ancestor __init__ method, even if the
    descendant defines it with a different argument list. And the same rule
    applies to any other method.

    Note:
    Guido, the original author of Python, explains method overriding this way:
    "Derived classes may override methods of their base classes. Because
    methods have no special privileges when calling other methods of the same
    object, a method of a base class that calls another method defined in the
    same base class, may in fact end up calling a method of a derived class
    that overrides it. (For C++ programmers: all methods in Python are
    effectively virtual.)" If that doesn't make sense to you (it confuses the
    hell out of me), feel free to ignore it. I just thought I'd pass it along.

    Caution:
    Always assign an initial value to all of an instance's data attributes in
    the __init__ method. It will save you hours of debugging later, tracking
    down AttributeError exceptions because you're referencing uninitialized
    (and therefore non-existent) attributes.



Example 5.10. UserDict Normal Methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def clear(self): self.data.clear()          (1)
    def copy(self):                             (2)
        if self.__class__ is UserDict:          (3)
            return UserDict(self.data)         
        import copy                             (4)
        return copy.copy(self)                 
    def keys(self): return self.data.keys()     (5)
    def items(self): return self.data.items()  
    def values(self): return self.data.values()

(1) clear is a normal class method; it is publicly available to be called by
    anyone at any time. Notice that clear, like all class methods, has self as
    its first argument. (Remember that you don't include self when you call the
    method; it's something that Python adds for you.) Also note the basic
    technique of this wrapper class: store a real dictionary (data) as a data
    attribute, define all the methods that a real dictionary has, and have each
    class method redirect to the corresponding method on the real dictionary.
    (In case you'd forgotten, a dictionary's clear method deletes all of its
    keys and their associated values.)
(2) The copy method of a real dictionary returns a new dictionary that is an
    exact duplicate of the original (all the same key-value pairs). But
    UserDict can't simply redirect to self.data.copy, because that method
    returns a real dictionary, and what you want is to return a new instance
    that is the same class as self.
(3) You use the __class__ attribute to see if self is a UserDict; if so, you're
    golden, because you know how to copy a UserDict: just create a new UserDict
    and give it the real dictionary that you've squirreled away in self.data.
    Then you immediately return the new UserDict you don't even get to the
    import copy on the next line.
(4) If self.__class__ is not UserDict, then self must be some subclass of
    UserDict (like maybe FileInfo), in which case life gets trickier. UserDict
    doesn't know how to make an exact copy of one of its descendants; there
    could, for instance, be other data attributes defined in the subclass, so
    you would need to iterate through them and make sure to copy all of them.
    Luckily, Python comes with a module to do exactly this, and it's called
    copy. I won't go into the details here (though it's a wicked cool module,
    if you're ever inclined to dive into it on your own). Suffice it to say
    that copy can copy arbitrary Python objects, and that's how you're using it
    here.
(5) The rest of the methods are straightforward, redirecting the calls to the
    built-in methods on self.data.

    Note: Historical Note
    In versions of Python prior to 2.2, you could not directly subclass
    built-in datatypes like strings, lists, and dictionaries. To compensate for
    this, Python comes with wrapper classes that mimic the behavior of these
    built-in datatypes: UserString, UserList, and UserDict. Using a combination
    of normal and special methods, the UserDict class does an excellent
    imitation of a dictionary. In Python 2.2 and later, you can inherit classes
    directly from built-in datatypes like dict. An example of this is given in
    the examples that come with this book, in fileinfo_fromdict.py.


In Python, you can inherit directly from the dict built-in datatype, as shown
in this example. There are three differences here compared to the UserDict
version.


Example 5.11. Inheriting Directly from Built-In Datatype dict
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class FileInfo(dict):                  (1)
        "store file metadata"
        def __init__(self, filename=None): (2)
            self["name"] = filename



(1) The first difference is that you don't need to import the UserDict module,
    since dict is a built-in datatype and is always available. The second is
    that you are inheriting from dict directly, instead of from
    UserDict.UserDict.
(2) The third difference is subtle but important. Because of the way UserDict
    works internally, it requires you to manually call its __init__ method to
    properly initialize its internal data structures. dict does not work like
    this; it is not a wrapper, and it requires no explicit initialization.


Further Reading on UserDict
   
  * Python Library Reference (http://www.python.org/doc/current/lib/)
    documents the UserDict module (http://www.python.org/doc/current/lib/
    module-UserDict.html) and the copy module (http://www.python.org/doc/
    current/lib/module-copy.html).

5.6. Special Class Methods
---------------------------



In addition to normal class methods, there are a number of special methods that
Python classes can define. Instead of being called directly by your code (like
normal methods), special methods are called for you by Python in particular
circumstances or when specific syntax is used.

As you saw in the previous section, normal methods go a long way towards
wrapping a dictionary in a class. But normal methods alone are not enough,
because there are a lot of things you can do with dictionaries besides call
methods on them. For starters, you can get and set items with a syntax that
doesn't include explicitly invoking methods. This is where special class
methods come in: they provide a way to map non-method-calling syntax into
method calls.

5.6.1. Getting and Setting Items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




Example 5.12. The __getitem__ Special Method
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



.. sourcecode:: python

    def __getitem__(self, key): return self.data[key]


::

    >>> f = fileinfo.FileInfo("/music/_singles/kairo.mp3")
    >>> f
    {'name':'/music/_singles/kairo.mp3'}
    >>> f.__getitem__("name") (1)
    '/music/_singles/kairo.mp3'
    >>> f["name"]             (2)
    '/music/_singles/kairo.mp3'

(1) The __getitem__ special method looks simple enough. Like the normal methods
    clear, keys, and values, it just redirects to the dictionary to return its
    value. But how does it get called? Well, you can call __getitem__ directly,
    but in practice you wouldn't actually do that; I'm just doing it here to
    show you how it works. The right way to use __getitem__ is to get Python to
    call it for you.
(2) This looks just like the syntax you would use to get a dictionary value,
    and in fact it returns the value you would expect. But here's the missing
    link: under the covers, Python has converted this syntax to the method call
    f.__getitem__("name"). That's why __getitem__ is a special class method;
    not only can you call it yourself, you can get Python to call it for you by
    using the right syntax.


Of course, Python has a __setitem__ special method to go along with
__getitem__, as shown in the next example.


Example 5.13. The __setitem__ Special Method
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



.. sourcecode:: python

    def __setitem__(self, key, item): self.data[key] = item


::

    >>> f
    {'name':'/music/_singles/kairo.mp3'}
    >>> f.__setitem__("genre", 31) (1)
    >>> f
    {'name':'/music/_singles/kairo.mp3', 'genre':31}
    >>> f["genre"] = 32            (2)
    >>> f
    {'name':'/music/_singles/kairo.mp3', 'genre':32}

(1) Like the __getitem__ method, __setitem__ simply redirects to the real
    dictionary self.data to do its work. And like __getitem__, you wouldn't
    ordinarily call it directly like this; Python calls __setitem__ for you
    when you use the right syntax.
(2) This looks like regular dictionary syntax, except of course that f is
    really a class that's trying very hard to masquerade as a dictionary, and
    __setitem__ is an essential part of that masquerade. This line of code
    actually calls f.__setitem__("genre", 32) under the covers.


__setitem__ is a special class method because it gets called for you, but it's
still a class method. Just as easily as the __setitem__ method was defined in
UserDict, you can redefine it in the descendant class to override the ancestor
method. This allows you to define classes that act like dictionaries in some
ways but define their own behavior above and beyond the built-in dictionary.

This concept is the basis of the entire framework you're studying in this
chapter. Each file type can have a handler class that knows how to get metadata
from a particular type of file. Once some attributes (like the file's name and
location) are known, the handler class knows how to derive other attributes
automatically. This is done by overriding the __setitem__ method, checking for
particular keys, and adding additional processing when they are found.

For example, MP3FileInfo is a descendant of FileInfo. When an MP3FileInfo's
name is set, it doesn't just set the name key (like the ancestor FileInfo
does); it also looks in the file itself for MP3 tags and populates a whole set
of keys. The next example shows how this works.


Example 5.14. Overriding __setitem__ in MP3FileInfo
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



.. sourcecode:: python

    def __setitem__(self, key, item):         (1)
        if key == "name" and item:            (2)
            self.__parse(item)                (3)
        FileInfo.__setitem__(self, key, item) (4)

(1) Notice that this __setitem__ method is defined exactly the same way as the
    ancestor method. This is important, since Python will be calling the method
    for you, and it expects it to be defined with a certain number of
    arguments. (Technically speaking, the names of the arguments don't matter;
    only the number of arguments is important.)
(2) Here's the crux of the entire MP3FileInfo class: if you're assigning a
    value to the name key, you want to do something extra.
(3) The extra processing you do for names is encapsulated in the __parse
    method. This is another class method defined in MP3FileInfo, and when you
    call it, you qualify it with self. Just calling __parse would look for a
    normal function defined outside the class, which is not what you want.
    Calling self.__parse will look for a class method defined within the class.
    This isn't anything new; you reference data attributes the same way.
(4) After doing this extra processing, you want to call the ancestor method.
    Remember that this is never done for you in Python; you must do it
    manually. Note that you're calling the immediate ancestor, FileInfo, even
    though it doesn't have a __setitem__ method. That's okay, because Python
    will walk up the ancestor tree until it finds a class with the method
    you're calling, so this line of code will eventually find and call the
    __setitem__ defined in UserDict.

    Note:
    When accessing data attributes within a class, you need to qualify the
    attribute name: self.attribute. When calling other methods within a class,
    you need to qualify the method name: self.method.



Example 5.15. Setting an MP3FileInfo's name
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



::

    >>> import fileinfo
    >>> mp3file = fileinfo.MP3FileInfo()                   (1)
    >>> mp3file
    {'name':None}
    >>> mp3file["name"] = "/music/_singles/kairo.mp3"      (2)
    >>> mp3file
    {'album': 'Rave Mix', 'artist': '***DJ MARY-JANE***', 'genre': 31,
    'title': 'KAIRO****THE BEST GOA', 'name': '/music/_singles/kairo.mp3',
    'year': '2000', 'comment': 'http://mp3.com/DJMARYJANE'}
    >>> mp3file["name"] = "/music/_singles/sidewinder.mp3" (3)
    >>> mp3file
    {'album': '', 'artist': 'The Cynic Project', 'genre': 18, 'title': 'Sidewinder', 
    'name': '/music/_singles/sidewinder.mp3', 'year': '2000', 
    'comment': 'http://mp3.com/cynicproject'}

(1) First, you create an instance of MP3FileInfo, without passing it a
    filename. (You can get away with this because the filename argument of the
    __init__ method is optional.) Since MP3FileInfo has no __init__ method of
    its own, Python walks up the ancestor tree and finds the __init__ method of
    FileInfo. This __init__ method manually calls the __init__ method of
    UserDict and then sets the name key to filename, which is None, since you
    didn't pass a filename. Thus, mp3file initially looks like a dictionary
    with one key, name, whose value is None.
(2) Now the real fun begins. Setting the name key of mp3file triggers the
    __setitem__ method on MP3FileInfo (not UserDict), which notices that you're
    setting the name key with a real value and calls self.__parse. Although you
    haven't traced through the __parse method yet, you can see from the output
    that it sets several other keys: album, artist, genre, title, year, and
    comment.
(3) Modifying the name key will go through the same process again: Python calls
    __setitem__, which calls self.__parse, which sets all the other keys.

5.7. Advanced Special Class Methods
------------------------------------



Python has more special methods than just __getitem__ and __setitem__. Some of
them let you emulate functionality that you may not even know about.

This example shows some of the other special methods in UserDict.


Example 5.16. More Special Methods in UserDict
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def __repr__(self): return repr(self.data)     (1)
    def __cmp__(self, dict):                       (2)
        if isinstance(dict, UserDict):            
            return cmp(self.data, dict.data)      
        else:                                     
            return cmp(self.data, dict)           
    def __len__(self): return len(self.data)       (3)
    def __delitem__(self, key): del self.data[key] (4)

(1) __repr__ is a special method that is called when you call repr(instance).
    The repr function is a built-in function that returns a string
    representation of an object. It works on any object, not just class
    instances. You're already intimately familiar with repr and you don't even
    know it. In the interactive window, when you type just a variable name and
    press the ENTER key, Python uses repr to display the variable's value. Go
    create a dictionary d with some data and then print repr(d) to see for
    yourself.
(2) __cmp__ is called when you compare class instances. In general, you can
    compare any two Python objects, not just class instances, by using ==.
    There are rules that define when built-in datatypes are considered equal;
    for instance, dictionaries are equal when they have all the same keys and
    values, and strings are equal when they are the same length and contain the
    same sequence of characters. For class instances, you can define the
    __cmp__ method and code the comparison logic yourself, and then you can use
    == to compare instances of your class and Python will call your __cmp__
    special method for you.
(3) __len__ is called when you call len(instance). The len function is a
    built-in function that returns the length of an object. It works on any
    object that could reasonably be thought of as having a length. The len of a
    string is its number of characters; the len of a dictionary is its number
    of keys; the len of a list or tuple is its number of elements. For class
    instances, define the __len__ method and code the length calculation
    yourself, and then call len(instance) and Python will call your __len__
    special method for you.
(4) __delitem__ is called when you call del instance[key], which you may
    remember as the way to delete individual items from a dictionary. When you
    use del on a class instance, Python calls the __delitem__ special method
    for you.

    Note: Python vs. Java equality and identity
    In Java, you determine whether two string variables reference the same
    physical memory location by using str1 == str2. This is called object
    identity, and it is written in Python as str1 is str2. To compare string
    values in Java, you would use str1.equals(str2); in Python, you would use
    str1 == str2. Java programmers who have been taught to believe that the
    world is a better place because == in Java compares by identity instead of
    by value may have a difficult time adjusting to Python's lack of such "
    gotchas".


At this point, you may be thinking, "All this work just to do something in a
class that I can do with a built-in datatype." And it's true that life would be
easier (and the entire UserDict class would be unnecessary) if you could
inherit from built-in datatypes like a dictionary. But even if you could,
special methods would still be useful, because they can be used in any class,
not just wrapper classes like UserDict.

Special methods mean that any class can store key/value pairs like a
dictionary, just by defining the __setitem__ method. Any class can act like a
sequence, just by defining the __getitem__ method. Any class that defines the
__cmp__ method can be compared with ==. And if your class represents something
that has a length, don't define a GetLength method; define the __len__ method
and use len(instance).
   
    Note:
    While other object-oriented languages only let you define the physical
    model of an object ("this object has a GetLength method"), Python's special
    class methods like __len__ allow you to define the logical model of an
    object ("this object has a length").


Python has a lot of other special methods. There's a whole set of them that let
classes act like numbers, allowing you to add, subtract, and do other
arithmetic operations on class instances. (The canonical example of this is a
class that represents complex numbers, numbers with both real and imaginary
components.) The __call__ method lets a class act like a function, allowing you
to call a class instance directly. And there are other special methods that
allow classes to have read-only and write-only data attributes; you'll talk
more about those in later chapters.

Further Reading on Special Class Methods
   
  * Python Reference Manual (http://www.python.org/doc/current/ref/)
    documents all the special class methods (http://www.python.org/doc/current/
    ref/specialnames.html).

5.8. Introducing Class Attributes
----------------------------------



You already know about data attributes, which are variables owned by a specific
instance of a class. Python also supports class attributes, which are variables
owned by the class itself.


Example 5.17. Introducing Class Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    class MP3FileInfo(FileInfo):
        "store ID3v1.0 MP3 tags"
        tagDataMap = {"title"   : (  3,  33, stripnulls),
                      "artist"  : ( 33,  63, stripnulls),
                      "album"   : ( 63,  93, stripnulls),
                      "year"    : ( 93,  97, stripnulls),
                      "comment" : ( 97, 126, stripnulls),
                  "genre"   : (127, 128, ord)}




::

    >>> import fileinfo
    >>> fileinfo.MP3FileInfo            (1)
    <class fileinfo.MP3FileInfo at 01257FDC>
    >>> fileinfo.MP3FileInfo.tagDataMap (2)
    {'title': (3, 33, <function stripnulls at 0260C8D4>), 
    'genre': (127, 128, <built-in function ord>), 
    'artist': (33, 63, <function stripnulls at 0260C8D4>), 
    'year': (93, 97, <function stripnulls at 0260C8D4>), 
    'comment': (97, 126, <function stripnulls at 0260C8D4>), 
    'album': (63, 93, <function stripnulls at 0260C8D4>)}
    >>> m = fileinfo.MP3FileInfo()      (3)
    >>> m.tagDataMap
    {'title': (3, 33, <function stripnulls at 0260C8D4>), 
    'genre': (127, 128, <built-in function ord>), 
    'artist': (33, 63, <function stripnulls at 0260C8D4>), 
    'year': (93, 97, <function stripnulls at 0260C8D4>), 
    'comment': (97, 126, <function stripnulls at 0260C8D4>), 
    'album': (63, 93, <function stripnulls at 0260C8D4>)}

(1) MP3FileInfo is the class itself, not any particular instance of the class.
(2) tagDataMap is a class attribute: literally, an attribute of the class. It
    is available before creating any instances of the class.
(3) Class attributes are available both through direct reference to the class
    and through any instance of the class.

    Note: Python vs. Java attribute definitions
    In Java, both static variables (called class attributes in Python) and
    instance variables (called data attributes in Python) are defined
    immediately after the class definition (one with the static keyword, one
    without). In Python, only class attributes can be defined here; data
    attributes are defined in the __init__ method.


Class attributes can be used as class-level constants (which is how you use
them in MP3FileInfo), but they are not really constants. You can also change
them.
   
    Note:
    There are no constants in Python. Everything can be changed if you try hard
    enough. This fits with one of the core principles of Python: bad behavior
    should be discouraged but not banned. If you really want to change the
    value of None, you can do it, but don't come running to me when your code
    is impossible to debug.



Example 5.18. Modifying Class Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> class counter:
    ...     count = 0                     (1)
    ...     def __init__(self):
    ...         self.__class__.count += 1 (2)
    ...     
    >>> counter
    <class __main__.counter at 010EAECC>
    >>> counter.count                     (3)
    0
    >>> c = counter()
    >>> c.count                           (4)
    1
    >>> counter.count
    1
    >>> d = counter()                     (5)
    >>> d.count
    2
    >>> c.count
    2
    >>> counter.count
    2

(1) count is a class attribute of the counter class.
(2) __class__ is a built-in attribute of every class instance (of every class).
    It is a reference to the class that self is an instance of (in this case,
    the counter class).
(3) Because count is a class attribute, it is available through direct
    reference to the class, before you have created any instances of the class.
(4) Creating an instance of the class calls the __init__ method, which
    increments the class attribute count by 1. This affects the class itself,
    not just the newly created instance.
(5) Creating a second instance will increment the class attribute count again.
    Notice how the class attribute is shared by the class and all instances of
    the class.

5.9. Private Functions
-----------------------



Like most languages, Python has the concept of private elements:
   
  * Private functions, which can't be called from outside their module
  * Private class methods, which can't be called from outside their class
  * Private attributes, which can't be accessed from outside their class.


Unlike in most languages, whether a Python function, method, or attribute is
private or public is determined entirely by its name.

If the name of a Python function, class method, or attribute starts with (but
doesn't end with) two underscores, it's private; everything else is public.
Python has no concept of protected class methods (accessible only in their own
class and descendant classes). Class methods are either private (accessible
only in their own class) or public (accessible from anywhere).

In MP3FileInfo, there are two methods: __parse and __setitem__. As you have
already discussed, __setitem__ is a special method; normally, you would call it
indirectly by using the dictionary syntax on a class instance, but it is
public, and you could call it directly (even from outside the fileinfo module)
if you had a really good reason. However, __parse is private, because it has
two underscores at the beginning of its name.
   
    Note: Method Naming Conventions
    In Python, all special methods (like __setitem__) and built-in attributes
    (like __doc__) follow a standard naming convention: they both start with
    and end with two underscores. Don't name your own methods and attributes
    this way, because it will only confuse you (and others) later.



Example 5.19. Trying to Call a Private Method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> import fileinfo
    >>> m = fileinfo.MP3FileInfo()
    >>> m.__parse("/music/_singles/kairo.mp3") (1)
    Traceback (innermost last):
      File "<interactive input>", line 1, in ?
    AttributeError: 'MP3FileInfo' instance has no attribute '__parse'

(1) If you try to call a private method, Python will raise a slightly
    misleading exception, saying that the method does not exist. Of course it
    does exist, but it's private, so it's not accessible outside the
    class.Strictly speaking, private methods are accessible outside their
    class, just not easily accessible. Nothing in Python is truly private;
    internally, the names of private methods and attributes are mangled and
    unmangled on the fly to make them seem inaccessible by their given names.
    You can access the __parse method of the MP3FileInfo class by the name
    _MP3FileInfo__parse. Acknowledge that this is interesting, but promise to
    never, ever do it in real code. Private methods are private for a reason,
    but like many other things in Python, their privateness is ultimately a
    matter of convention, not force.


Further Reading on Private Functions
   
  * Python Tutorial (http://www.python.org/doc/current/tut/tut.html)
    discusses the inner workings of private variables (http://www.python.org/
    doc/current/tut/node11.html#SECTION0011600000000000000000).

5.10. Summary
--------------



That's it for the hard-core object trickery. You'll see a real-world
application of special class methods in Chapter 12, which uses getattr to
create a proxy to a remote web service.

The next chapter will continue using this code sample to explore other Python
concepts, such as exceptions, file objects, and for loops.

Before diving into the next chapter, make sure you're comfortable doing all of
these things:
   
  * Importing modules using either import module or from module import
  * Defining and instantiating classes
  * Defining __init__ methods and other special class methods, and
    understanding when they are called
  * Subclassing UserDict to define classes that act like dictionaries
  * Defining data attributes and class attributes, and understanding the
    differences between them
  * Defining private attributes and methods


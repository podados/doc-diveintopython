Chapter 14. Test-First Programming
===================================
14.1. roman.py, stage 1
------------------------



Now that the unit tests are complete, it's time to start writing the code that
the test cases are attempting to test. You're going to do this in stages, so
you can see all the unit tests fail, then watch them pass one by one as you
fill in the gaps in roman.py.


Example 14.1. roman1.py
~~~~~~~~~~~~~~~~~~~~~~~~


This file is available in py/roman/stage1/ in the examples directory.

If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Convert to and from Roman numerals"""
    
    #Define exceptions
    class RomanError(Exception): pass                (1)
    class OutOfRangeError(RomanError): pass          (2)
    class NotIntegerError(RomanError): pass
    class InvalidRomanNumeralError(RomanError): pass (3)
    
    def toRoman(n):
        """convert integer to Roman numeral"""
        pass                                         (4)
    
    def fromRoman(s):
        """convert Roman numeral to integer"""
        pass



(1) This is how you define your own custom exceptions in Python. Exceptions are
    classes, and you create your own by subclassing existing exceptions. It is
    strongly recommended (but not required) that you subclass Exception, which
    is the base class that all built-in exceptions inherit from. Here I am
    defining RomanError (inherited from Exception) to act as the base class for
    all my other custom exceptions to follow. This is a matter of style; I
    could just as easily have inherited each individual exception from the
    Exception class directly.
(2) The OutOfRangeError and NotIntegerError exceptions will eventually be used
    by toRoman to flag various forms of invalid input, as specified in
    ToRomanBadInput.
(3) The InvalidRomanNumeralError exception will eventually be used by fromRoman
    to flag invalid input, as specified in FromRomanBadInput.
(4) At this stage, you want to define the API of each of your functions, but
    you don't want to code them yet, so you stub them out using the Python
    reserved word pass.


Now for the big moment (drum roll please): you're finally going to run the unit
test against this stubby little module. At this point, every test case should
fail. In fact, if any test case passes in stage 1, you should go back to
romantest.py and re-evaluate why you coded a test so useless that it passes
with do-nothing functions.

Run romantest1.py with the -v command-line option, which will give more verbose
output so you can see exactly what's going on as each test case runs. With any
luck, your output should look like this:


Example 14.2. Output of romantest1.py against roman1.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    fromRoman should only accept uppercase input ... ERROR
    toRoman should always return uppercase ... ERROR
    fromRoman should fail with malformed antecedents ... FAIL
    fromRoman should fail with repeated pairs of numerals ... FAIL
    fromRoman should fail with too many repeated numerals ... FAIL
    fromRoman should give known result with known input ... FAIL
    toRoman should give known result with known input ... FAIL
    fromRoman(toRoman(n))==n for all n ... FAIL
    toRoman should fail with non-integer input ... FAIL
    toRoman should fail with negative input ... FAIL
    toRoman should fail with large input ... FAIL
    toRoman should fail with 0 input ... FAIL
    
    ======================================================================
    ERROR: fromRoman should only accept uppercase input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 154, in testFromRomanCase
        roman1.fromRoman(numeral.upper())
    AttributeError: 'None' object has no attribute 'upper'
    ======================================================================
    ERROR: toRoman should always return uppercase
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 148, in testToRomanCase
        self.assertEqual(numeral, numeral.upper())
    AttributeError: 'None' object has no attribute 'upper'
    ======================================================================
    FAIL: fromRoman should fail with malformed antecedents
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 133, in testMalformedAntecedent
        self.assertRaises(roman1.InvalidRomanNumeralError, roman1.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with repeated pairs of numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 127, in testRepeatedPairs
        self.assertRaises(roman1.InvalidRomanNumeralError, roman1.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with too many repeated numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 122, in testTooManyRepeatedNumerals
        self.assertRaises(roman1.InvalidRomanNumeralError, roman1.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should give known result with known input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 99, in testFromRomanKnownValues
        self.assertEqual(integer, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: 1 != None
    ======================================================================
    FAIL: toRoman should give known result with known input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 93, in testToRomanKnownValues
        self.assertEqual(numeral, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: I != None
    ======================================================================
    FAIL: fromRoman(toRoman(n))==n for all n
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 141, in testSanity
        self.assertEqual(integer, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: 1 != None
    ======================================================================
    FAIL: toRoman should fail with non-integer input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 116, in testNonInteger
        self.assertRaises(roman1.NotIntegerError, roman1.toRoman, 0.5)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: NotIntegerError
    ======================================================================
    FAIL: toRoman should fail with negative input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 112, in testNegative
        self.assertRaises(roman1.OutOfRangeError, roman1.toRoman, -1)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: OutOfRangeError
    ======================================================================
    FAIL: toRoman should fail with large input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 104, in testTooLarge
        self.assertRaises(roman1.OutOfRangeError, roman1.toRoman, 4000)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: OutOfRangeError
    ======================================================================
    FAIL: toRoman should fail with 0 input                                 (1)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 108, in testZero
        self.assertRaises(roman1.OutOfRangeError, roman1.toRoman, 0)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: OutOfRangeError                                        (2)
    ----------------------------------------------------------------------
    Ran 12 tests in 0.040s                                                 (3)
    
    FAILED (failures=10, errors=2)                                         (4)



(1) Running the script runs unittest.main(), which runs each test case, which
    is to say each method defined in each class within romantest.py. For each
    test case, it prints out the doc string of the method and whether that test
    passed or failed. As expected, none of the test cases passed.
(2) For each failed test case, unittest displays the trace information showing
    exactly what happened. In this case, the call to assertRaises (also called
    failUnlessRaises) raised an AssertionError because it was expecting toRoman
    to raise an OutOfRangeError and it didn't.
(3) After the detail, unittest displays a summary of how many tests were
    performed and how long it took.
(4) Overall, the unit test failed because at least one test case did not pass.
    When a test case doesn't pass, unittest distinguishes between failures and
    errors. A failure is a call to an assertXYZ method, like assertEqual or
    assertRaises, that fails because the asserted condition is not true or the
    expected exception was not raised. An error is any other sort of exception
    raised in the code you're testing or the unit test case itself. For
    instance, the testFromRomanCase method ("fromRoman should only accept
    uppercase input") was an error, because the call to numeral.upper() raised
    an AttributeError exception, because toRoman was supposed to return a
    string but didn't. But testZero ("toRoman should fail with 0 input") was a
    failure, because the call to fromRoman did not raise the
    InvalidRomanNumeral exception that assertRaises was looking for.

14.2. roman.py, stage 2
------------------------



Now that you have the framework of the roman module laid out, it's time to
start writing code and passing test cases.


Example 14.3. roman2.py
~~~~~~~~~~~~~~~~~~~~~~~~


This file is available in py/roman/stage2/ in the examples directory.

If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Convert to and from Roman numerals"""
    
    #Define exceptions
    class RomanError(Exception): pass
    class OutOfRangeError(RomanError): pass
    class NotIntegerError(RomanError): pass
    class InvalidRomanNumeralError(RomanError): pass
    
    #Define digit mapping
    romanNumeralMap = (('M',  1000), (1)
                       ('CM', 900),
                       ('D',  500),
                       ('CD', 400),
                       ('C',  100),
                       ('XC', 90),
                       ('L',  50),
                       ('XL', 40),
                       ('X',  10),
                       ('IX', 9),
                       ('V',  5),
                       ('IV', 4),
                       ('I',  1))
    
    def toRoman(n):
        """convert integer to Roman numeral"""
        result = ""
        for numeral, integer in romanNumeralMap:
            while n >= integer:      (2)
                result += numeral
                n -= integer
        return result
    
    def fromRoman(s):
        """convert Roman numeral to integer"""
        pass



(1) romanNumeralMap is a tuple of tuples which defines three things:
     1. The character representations of the most basic Roman numerals. Note
        that this is not just the single-character Roman numerals; you're also
        defining two-character pairs like CM ("one hundred less than one
        thousand"); this will make the toRoman code simpler later.
     2. The order of the Roman numerals. They are listed in descending value
        order, from M all the way down to I.
     3. The value of each Roman numeral. Each inner tuple is a pair of (numeral,
        value).
   
(2) Here's where your rich data structure pays off, because you don't need any
    special logic to handle the subtraction rule. To convert to Roman numerals,
    you simply iterate through romanNumeralMap looking for the largest integer
    value less than or equal to the input. Once found, you add the Roman
    numeral representation to the end of the output, subtract the corresponding
    integer value from the input, lather, rinse, repeat.



Example 14.4. How toRoman works
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


If you're not clear how toRoman works, add a print statement to the end of the
while loop:


::

        while n >= integer:
            result += numeral
            n -= integer
            print 'subtracting', integer, 'from input, adding', numeral, 'to output'


::

    >>> import roman2
    >>> roman2.toRoman(1424)
    subtracting 1000 from input, adding M to output
    subtracting 400 from input, adding CD to output
    subtracting 10 from input, adding X to output
    subtracting 10 from input, adding X to output
    subtracting 4 from input, adding IV to output
    'MCDXXIV'

So toRoman appears to work, at least in this manual spot check. But will it
pass the unit testing? Well no, not entirely.


Example 14.5. Output of romantest2.py against roman2.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Remember to run romantest2.py with the -v command-line flag to enable verbose
mode.


::

    fromRoman should only accept uppercase input ... FAIL
    toRoman should always return uppercase ... ok                  (1)
    fromRoman should fail with malformed antecedents ... FAIL
    fromRoman should fail with repeated pairs of numerals ... FAIL
    fromRoman should fail with too many repeated numerals ... FAIL
    fromRoman should give known result with known input ... FAIL
    toRoman should give known result with known input ... ok       (2)
    fromRoman(toRoman(n))==n for all n ... FAIL
    toRoman should fail with non-integer input ... FAIL            (3)
    toRoman should fail with negative input ... FAIL
    toRoman should fail with large input ... FAIL
    toRoman should fail with 0 input ... FAIL



(1) toRoman does, in fact, always return uppercase, because romanNumeralMap
    defines the Roman numeral representations as uppercase. So this test passes
    already.
(2) Here's the big news: this version of the toRoman function passes the known
    values test. Remember, it's not comprehensive, but it does put the function
    through its paces with a variety of good inputs, including inputs that
    produce every single-character Roman numeral, the largest possible input
    (3999), and the input that produces the longest possible Roman numeral
    (3888). At this point, you can be reasonably confident that the function
    works for any good input value you could throw at it.
(3) However, the function does not "work" for bad values; it fails every single
    bad input test. That makes sense, because you didn't include any checks for
    bad input. Those test cases look for specific exceptions to be raised (via
    assertRaises), and you're never raising them. You'll do that in the next
    stage.


Here's the rest of the output of the unit test, listing the details of all the
failures. You're down to 10.



::

    ======================================================================
    FAIL: fromRoman should only accept uppercase input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 156, in testFromRomanCase
        roman2.fromRoman, numeral.lower())
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with malformed antecedents
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 133, in testMalformedAntecedent
        self.assertRaises(roman2.InvalidRomanNumeralError, roman2.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with repeated pairs of numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 127, in testRepeatedPairs
        self.assertRaises(roman2.InvalidRomanNumeralError, roman2.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with too many repeated numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 122, in testTooManyRepeatedNumerals
        self.assertRaises(roman2.InvalidRomanNumeralError, roman2.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should give known result with known input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 99, in testFromRomanKnownValues
        self.assertEqual(integer, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: 1 != None
    ======================================================================
    FAIL: fromRoman(toRoman(n))==n for all n
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 141, in testSanity
        self.assertEqual(integer, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: 1 != None
    ======================================================================
    FAIL: toRoman should fail with non-integer input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 116, in testNonInteger
        self.assertRaises(roman2.NotIntegerError, roman2.toRoman, 0.5)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: NotIntegerError
    ======================================================================
    FAIL: toRoman should fail with negative input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 112, in testNegative
        self.assertRaises(roman2.OutOfRangeError, roman2.toRoman, -1)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: OutOfRangeError
    ======================================================================
    FAIL: toRoman should fail with large input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 104, in testTooLarge
        self.assertRaises(roman2.OutOfRangeError, roman2.toRoman, 4000)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: OutOfRangeError
    ======================================================================
    FAIL: toRoman should fail with 0 input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 108, in testZero
        self.assertRaises(roman2.OutOfRangeError, roman2.toRoman, 0)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: OutOfRangeError
    ----------------------------------------------------------------------
    Ran 12 tests in 0.320s
    
    FAILED (failures=10)



14.3. roman.py, stage 3
------------------------



Now that toRoman behaves correctly with good input (integers from 1 to 3999),
it's time to make it behave correctly with bad input (everything else).


Example 14.6. roman3.py
~~~~~~~~~~~~~~~~~~~~~~~~


This file is available in py/roman/stage3/ in the examples directory.

If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Convert to and from Roman numerals"""
    
    #Define exceptions
    class RomanError(Exception): pass
    class OutOfRangeError(RomanError): pass
    class NotIntegerError(RomanError): pass
    class InvalidRomanNumeralError(RomanError): pass
    
    #Define digit mapping
    romanNumeralMap = (('M',  1000),
                       ('CM', 900),
                       ('D',  500),
                       ('CD', 400),
                       ('C',  100),
                       ('XC', 90),
                       ('L',  50),
                       ('XL', 40),
                       ('X',  10),
                       ('IX', 9),
                       ('V',  5),
                       ('IV', 4),
                       ('I',  1))
    
    def toRoman(n):
        """convert integer to Roman numeral"""
        if not (0 < n < 4000):                                             (1)
            raise OutOfRangeError, "number out of range (must be 1..3999)" (2)
        if int(n) <> n:                                                    (3)
            raise NotIntegerError, "non-integers can not be converted"
    
        result = ""                                                        (4)
        for numeral, integer in romanNumeralMap:
            while n >= integer:
                result += numeral
                n -= integer
        return result
    
    def fromRoman(s):
        """convert Roman numeral to integer"""
        pass



(1) This is a nice Pythonic shortcut: multiple comparisons at once. This is
    equivalent to if not ((0 < n) and (n < 4000)), but it's much easier to
    read. This is the range check, and it should catch inputs that are too
    large, negative, or zero.
(2) You raise exceptions yourself with the raise statement. You can raise any
    of the built-in exceptions, or you can raise any of your custom exceptions
    that you've defined. The second parameter, the error message, is optional;
    if given, it is displayed in the traceback that is printed if the exception
    is never handled.
(3) This is the non-integer check. Non-integers can not be converted to Roman
    numerals.
(4) The rest of the function is unchanged.



Example 14.7. Watching toRoman handle bad input
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



::

    >>> import roman3
    >>> roman3.toRoman(4000)
    Traceback (most recent call last):
      File "<interactive input>", line 1, in ?
      File "roman3.py", line 27, in toRoman
        raise OutOfRangeError, "number out of range (must be 1..3999)"
    OutOfRangeError: number out of range (must be 1..3999)
    >>> roman3.toRoman(1.5)
    Traceback (most recent call last):
      File "<interactive input>", line 1, in ?
      File "roman3.py", line 29, in toRoman
        raise NotIntegerError, "non-integers can not be converted"
    NotIntegerError: non-integers can not be converted


Example 14.8. Output of romantest3.py against roman3.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    fromRoman should only accept uppercase input ... FAIL
    toRoman should always return uppercase ... ok
    fromRoman should fail with malformed antecedents ... FAIL
    fromRoman should fail with repeated pairs of numerals ... FAIL
    fromRoman should fail with too many repeated numerals ... FAIL
    fromRoman should give known result with known input ... FAIL
    toRoman should give known result with known input ... ok (1)
    fromRoman(toRoman(n))==n for all n ... FAIL
    toRoman should fail with non-integer input ... ok        (2)
    toRoman should fail with negative input ... ok           (3)
    toRoman should fail with large input ... ok
    toRoman should fail with 0 input ... ok



(1) toRoman still passes the known values test, which is comforting. All the
    tests that passed in stage 2 still pass, so the latest code hasn't broken
    anything.
(2) More exciting is the fact that all of the bad input tests now pass. This
    test, testNonInteger, passes because of the int(n) <> n check. When a
    non-integer is passed to toRoman, the int(n) <> n check notices it and
    raises the NotIntegerError exception, which is what testNonInteger is
    looking for.
(3) This test, testNegative, passes because of the not (0 < n < 4000) check,
    which raises an OutOfRangeError exception, which is what testNegative is
    looking for.




::

    ======================================================================
    FAIL: fromRoman should only accept uppercase input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 156, in testFromRomanCase
        roman3.fromRoman, numeral.lower())
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with malformed antecedents
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 133, in testMalformedAntecedent
        self.assertRaises(roman3.InvalidRomanNumeralError, roman3.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with repeated pairs of numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 127, in testRepeatedPairs
        self.assertRaises(roman3.InvalidRomanNumeralError, roman3.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with too many repeated numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 122, in testTooManyRepeatedNumerals
        self.assertRaises(roman3.InvalidRomanNumeralError, roman3.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should give known result with known input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 99, in testFromRomanKnownValues
        self.assertEqual(integer, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: 1 != None
    ======================================================================
    FAIL: fromRoman(toRoman(n))==n for all n
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 141, in testSanity
        self.assertEqual(integer, result)
      File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
        raise self.failureException, (msg or '%s != %s' % (first, second))
    AssertionError: 1 != None
    ----------------------------------------------------------------------
    Ran 12 tests in 0.401s
    
    FAILED (failures=6) (1)



(1) You're down to 6 failures, and all of them involve fromRoman: the known
    values test, the three separate bad input tests, the case check, and the
    sanity check. That means that toRoman has passed all the tests it can pass
    by itself. (It's involved in the sanity check, but that also requires that
    fromRoman be written, which it isn't yet.) Which means that you must stop
    coding toRoman now. No tweaking, no twiddling, no extra checks "just in
    case". Stop. Now. Back away from the keyboard.

    Note: Know when to stop coding
    The most important thing that comprehensive unit testing can tell you is
    when to stop coding. When all the unit tests for a function pass, stop
    coding the function. When all the unit tests for an entire module pass,
    stop coding the module.

14.4. roman.py, stage 4
------------------------



Now that toRoman is done, it's time to start coding fromRoman. Thanks to the
rich data structure that maps individual Roman numerals to integer values, this
is no more difficult than the toRoman function.


Example 14.9. roman4.py
~~~~~~~~~~~~~~~~~~~~~~~~


This file is available in py/roman/stage4/ in the examples directory.

If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Convert to and from Roman numerals"""
    
    #Define exceptions
    class RomanError(Exception): pass
    class OutOfRangeError(RomanError): pass
    class NotIntegerError(RomanError): pass
    class InvalidRomanNumeralError(RomanError): pass
    
    #Define digit mapping
    romanNumeralMap = (('M',  1000),
                       ('CM', 900),
                       ('D',  500),
                       ('CD', 400),
                       ('C',  100),
                       ('XC', 90),
                       ('L',  50),
                       ('XL', 40),
                       ('X',  10),
                       ('IX', 9),
                       ('V',  5),
                       ('IV', 4),
                       ('I',  1))
    
    # toRoman function omitted for clarity (it hasn't changed)
    
    def fromRoman(s):
        """convert Roman numeral to integer"""
        result = 0
        index = 0
        for numeral, integer in romanNumeralMap:
            while s[index:index+len(numeral)] == numeral: (1)
                result += integer
                index += len(numeral)
        return result



(1) The pattern here is the same as toRoman. You iterate through your Roman
    numeral data structure (a tuple of tuples), and instead of matching the
    highest integer values as often as possible, you match the "highest" Roman
    numeral character strings as often as possible.



Example 14.10. How fromRoman works
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


If you're not clear how fromRoman works, add a print statement to the end of
the while loop:


::

        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
            print 'found', numeral, 'of length', len(numeral), ', adding', integer


::

    >>> import roman4
    >>> roman4.fromRoman('MCMLXXII')
    found M , of length 1, adding 1000
    found CM , of length 2, adding 900
    found L , of length 1, adding 50
    found X , of length 1, adding 10
    found X , of length 1, adding 10
    found I , of length 1, adding 1
    found I , of length 1, adding 1
    1972


Example 14.11. Output of romantest4.py against roman4.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    fromRoman should only accept uppercase input ... FAIL
    toRoman should always return uppercase ... ok
    fromRoman should fail with malformed antecedents ... FAIL
    fromRoman should fail with repeated pairs of numerals ... FAIL
    fromRoman should fail with too many repeated numerals ... FAIL
    fromRoman should give known result with known input ... ok (1)
    toRoman should give known result with known input ... ok
    fromRoman(toRoman(n))==n for all n ... ok                  (2)
    toRoman should fail with non-integer input ... ok
    toRoman should fail with negative input ... ok
    toRoman should fail with large input ... ok
    toRoman should fail with 0 input ... ok



(1) Two pieces of exciting news here. The first is that fromRoman works for
    good input, at least for all the known values you test.
(2) The second is that the sanity check also passed. Combined with the known
    values tests, you can be reasonably sure that both toRoman and fromRoman
    work properly for all possible good values. (This is not guaranteed; it is
    theoretically possible that toRoman has a bug that produces the wrong Roman
    numeral for some particular set of inputs, and that fromRoman has a
    reciprocal bug that produces the same wrong integer values for exactly that
    set of Roman numerals that toRoman generated incorrectly. Depending on your
    application and your requirements, this possibility may bother you; if so,
    write more comprehensive test cases until it doesn't bother you.)




::

    ======================================================================
    FAIL: fromRoman should only accept uppercase input
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 156, in testFromRomanCase
        roman4.fromRoman, numeral.lower())
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with malformed antecedents
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 133, in testMalformedAntecedent
        self.assertRaises(roman4.InvalidRomanNumeralError, roman4.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with repeated pairs of numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 127, in testRepeatedPairs
        self.assertRaises(roman4.InvalidRomanNumeralError, roman4.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ======================================================================
    FAIL: fromRoman should fail with too many repeated numerals
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 122, in testTooManyRepeatedNumerals
        self.assertRaises(roman4.InvalidRomanNumeralError, roman4.fromRoman, s)
      File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
        raise self.failureException, excName
    AssertionError: InvalidRomanNumeralError
    ----------------------------------------------------------------------
    Ran 12 tests in 1.222s
    
    FAILED (failures=4)



14.5. roman.py, stage 5
------------------------



Now that fromRoman works properly with good input, it's time to fit in the last
piece of the puzzle: making it work properly with bad input. That means finding
a way to look at a string and determine if it's a valid Roman numeral. This is
inherently more difficult than validating numeric input in toRoman, but you
have a powerful tool at your disposal: regular expressions.

If you're not familiar with regular expressions and didn't read Chapter 7,
Regular Expressions, now would be a good time.

As you saw in Section 7.3, ??Case Study: Roman Numerals??, there are several
simple rules for constructing a Roman numeral, using the letters M, D, C, L, X,
V, and I. Let's review the rules:
   
 1. Characters are additive. I is 1, II is 2, and III is 3. VI is 6 (literally,
    "5 and 1"), VII is 7, and VIII is 8.
 2. The tens characters (I, X, C, and M) can be repeated up to three times. At
    4, you need to subtract from the next highest fives character. You can't
    represent 4 as IIII; instead, it is represented as IV ("1 less than 5"). 40
    is written as XL ("10 less than 50"), 41 as XLI, 42 as XLII, 43 as XLIII,
    and then 44 as XLIV ("10 less than 50, then 1 less than 5").
 3. Similarly, at 9, you need to subtract from the next highest tens character:
    8 is VIII, but 9 is IX ("1 less than 10"), not VIIII (since the I character
    can not be repeated four times). 90 is XC, 900 is CM.
 4. The fives characters can not be repeated. 10 is always represented as X,
    never as VV. 100 is always C, never LL.
 5. Roman numerals are always written highest to lowest, and read left to right,
    so order of characters matters very much. DC is 600; CD is a completely
    different number (400, "100 less than 500"). CI is 101; IC is not even a
    valid Roman numeral (because you can't subtract 1 directly from 100; you
    would need to write it as XCIX, "10 less than 100, then 1 less than 10").



Example 14.12. roman5.py
~~~~~~~~~~~~~~~~~~~~~~~~~


This file is available in py/roman/stage5/ in the examples directory.

If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    """Convert to and from Roman numerals"""
    import re
    
    #Define exceptions
    class RomanError(Exception): pass
    class OutOfRangeError(RomanError): pass
    class NotIntegerError(RomanError): pass
    class InvalidRomanNumeralError(RomanError): pass
    
    #Define digit mapping
    romanNumeralMap = (('M',  1000),
                       ('CM', 900),
                       ('D',  500),
                       ('CD', 400),
                       ('C',  100),
                       ('XC', 90),
                       ('L',  50),
                       ('XL', 40),
                       ('X',  10),
                       ('IX', 9),
                       ('V',  5),
                       ('IV', 4),
                       ('I',  1))
    
    def toRoman(n):
        """convert integer to Roman numeral"""
        if not (0 < n < 4000):
            raise OutOfRangeError, "number out of range (must be 1..3999)"
        if int(n) <> n:
            raise NotIntegerError, "non-integers can not be converted"
    
        result = ""
        for numeral, integer in romanNumeralMap:
            while n >= integer:
                result += numeral
                n -= integer
        return result
    
    #Define pattern to detect valid Roman numerals
    romanNumeralPattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$' (1)
    
    def fromRoman(s):
        """convert Roman numeral to integer"""
        if not re.search(romanNumeralPattern, s):                                    (2)
            raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s
    
        result = 0
        index = 0
        for numeral, integer in romanNumeralMap:
            while s[index:index+len(numeral)] == numeral:
                result += integer
                index += len(numeral)
        return result



(1) This is just a continuation of the pattern you discussed in Section 7.3, ??
    Case Study: Roman Numerals??. The tens places is either XC (90), XL (40),
    or an optional L followed by 0 to 3 optional X characters. The ones place
    is either IX (9), IV (4), or an optional V followed by 0 to 3 optional I
    characters.
(2) Having encoded all that logic into a regular expression, the code to check
    for invalid Roman numerals becomes trivial. If re.search returns an object,
    then the regular expression matched and the input is valid; otherwise, the
    input is invalid.


At this point, you are allowed to be skeptical that that big ugly regular
expression could possibly catch all the types of invalid Roman numerals. But
don't take my word for it, look at the results:


Example 14.13. Output of romantest5.py against roman5.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




::

    fromRoman should only accept uppercase input ... ok          (1)
    toRoman should always return uppercase ... ok
    fromRoman should fail with malformed antecedents ... ok      (2)
    fromRoman should fail with repeated pairs of numerals ... ok (3)
    fromRoman should fail with too many repeated numerals ... ok
    fromRoman should give known result with known input ... ok
    toRoman should give known result with known input ... ok
    fromRoman(toRoman(n))==n for all n ... ok
    toRoman should fail with non-integer input ... ok
    toRoman should fail with negative input ... ok
    toRoman should fail with large input ... ok
    toRoman should fail with 0 input ... ok
    
    ----------------------------------------------------------------------
    Ran 12 tests in 2.864s
    
    OK                                                           (4)



(1) One thing I didn't mention about regular expressions is that, by default,
    they are case-sensitive. Since the regular expression romanNumeralPattern
    was expressed in uppercase characters, the re.search check will reject any
    input that isn't completely uppercase. So the uppercase input test passes.
(2) More importantly, the bad input tests pass. For instance, the malformed
    antecedents test checks cases like MCMC. As you've seen, this does not
    match the regular expression, so fromRoman raises an
    InvalidRomanNumeralError exception, which is what the malformed antecedents
    test case is looking for, so the test passes.
(3) In fact, all the bad input tests pass. This regular expression catches
    everything you could think of when you made your test cases.
(4) And the anticlimax award of the year goes to the word "OK", which is
    printed by the unittest module when all the tests pass.

    Note: What to do when all of your tests pass
    When all of your tests pass, stop coding.


Chapter 2. Your First Python Program
=====================================

You know how other books go on and on about programming fundamentals and
finally work up to building a complete, working program? Let's skip all that.

2.1. Diving in
---------------



Here is a complete, working Python program.

It probably makes absolutely no sense to you. Don't worry about that, because
you're going to dissect it line by line. But read through it first and see
what, if anything, you can make of it.


Example 2.1. odbchelper.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~


If you have not already done so, you can download this and other examples (
http://diveintopython.org/download/diveintopython-examples-5.4.zip) used in
this book.


::

    def buildConnectionString(params):
        """Build a connection string from a dictionary of parameters.
    
        Returns string."""
        return ";".join(["%s=%s" % (k, v) for k, v in params.items()])
    
    if __name__ == "__main__":
        myParams = {"server":"mpilgrim", \
                    "database":"master", \
                    "uid":"sa", \
                    "pwd":"secret" \
                    }
        print buildConnectionString(myParams)



Now run this program and see what happens.
   
    Tip: Running Programs on Windows
    In the ActivePython IDE on Windows, you can run the Python program you're
    editing by choosing File->Run... (Ctrl-R). Output is displayed in the
    interactive window.

    Tip: Running Programs on Mac OS
    In the Python IDE on Mac OS, you can run a Python program with Python->Run
    window... (Cmd-R), but there is an important option you must set first.
    Open the .py file in the IDE, pop up the options menu by clicking the black
    triangle in the upper-right corner of the window, and make sure the Run as
    __main__ option is checked. This is a per-file setting, but you'll only
    need to do it once per file.

    Tip: Running Programs in UNIX
    On UNIX-compatible systems (including Mac OS X), you can run a Python
    program from the command line: python odbchelper.py



The output of odbchelper.py will look like this:


::

    server=mpilgrim;uid=sa;database=master;pwd=secret
    
2.2. Declaring Functions
-------------------------





Python has functions like most other languages, but it does not have separate
header files like C++ or interface/implementation sections like Pascal. When
you need a function, just declare it, like this:
def buildConnectionString(params):

Note that the keyword def starts the function declaration, followed by the
function name, followed by the arguments in parentheses. Multiple arguments
(not shown here) are separated with commas.

Also note that the function doesn't define a return datatype. Python functions
do not specify the datatype of their return value; they don't even specify
whether or not they return a value. In fact, every Python function returns a
value; if the function ever executes a return statement, it will return that
value, otherwise it will return None, the Python null value.
   
    Note: Python vs. Visual Basic: Return Values
    In Visual Basic, functions (that return a value) start with function, and
    subroutines (that do not return a value) start with sub. There are no
    subroutines in Python. Everything is a function, all functions return a
    value (even if it's None), and all functions start with def.


The argument, params, doesn't specify a datatype. In Python, variables are
never explicitly typed. Python figures out what type a variable is and keeps
track of it internally.
   
    Note: Python vs. Java: Return Values
    In Java, C++, and other statically-typed languages, you must specify the
    datatype of the function return value and each function argument. In Python
    , you never explicitly specify the datatype of anything. Based on what
    value you assign, Python keeps track of the datatype internally.

2.2.1. How Python's Datatypes Compare to Other Programming Languages
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



An erudite reader sent me this explanation of how Python compares to other
programming languages:

statically typed language
    A language in which types are fixed at compile time. Most statically typed
    languages enforce this by requiring you to declare all variables with their
    datatypes before using them. Java and C are statically typed languages.
dynamically typed language
    A language in which types are discovered at execution time; the opposite of
    statically typed. VBScript and Python are dynamically typed, because they
    figure out what type a variable is when you first assign it a value.
strongly typed language
    A language in which types are always enforced. Java and Python are strongly
    typed. If you have an integer, you can't treat it like a string without
    explicitly converting it.
weakly typed language
    A language in which types may be ignored; the opposite of strongly typed.
    VBScript is weakly typed. In VBScript, you can concatenate the string '12'
    and the integer 3 to get the string '123', then treat that as the integer
    123, all without any explicit conversion.


So Python is both dynamically typed (because it doesn't use explicit datatype
declarations) and strongly typed (because once a variable has a datatype, it
actually matters).

2.3. Documenting Functions
---------------------------



You can document a Python function by giving it a doc string.


Example 2.2. Defining the buildConnectionString Function's doc string
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def buildConnectionString(params):
        """Build a connection string from a dictionary of parameters.
    
        Returns string."""



Triple quotes signify a multi-line string. Everything between the start and end
quotes is part of a single string, including carriage returns and other quote
characters. You can use them anywhere, but you'll see them most often used when
defining a doc string.
   
    Note: Python vs. Perl: Quoting
    Triple quotes are also an easy way to define a string with both single and
    double quotes, like qq/.../ in Perl.


Everything between the triple quotes is the function's doc string, which
documents what the function does. A doc string, if it exists, must be the first
thing defined in a function (that is, the first thing after the colon). You
don't technically need to give your function a doc string, but you always
should. I know you've heard this in every programming class you've ever taken,
but Python gives you an added incentive: the doc string is available at runtime
as an attribute of the function.
   
    Note: Why doc strings are a Good Thing
    Many Python IDEs use the doc string to provide context-sensitive
    documentation, so that when you type a function name, its doc string
    appears as a tooltip. This can be incredibly helpful, but it's only as good
    as the doc strings you write.


Further Reading on Documenting Functions
   
  * PEP 257 (http://www.python.org/peps/pep-0257.html) defines doc string
    conventions.
  * Python Style Guide (http://www.python.org/doc/essays/styleguide.html)
    discusses how to write a good doc string.
  * Python Tutorial (http://www.python.org/doc/current/tut/tut.html)
    discusses conventions for spacing in doc strings (http://www.python.org/doc
    /current/tut/node6.html#SECTION006750000000000000000).

2.4. Everything Is an Object
-----------------------------



In case you missed it, I just said that Python functions have attributes, and
that those attributes are available at runtime.

A function, like everything else in Python, is an object.

Open your favorite Python IDE and follow along:


Example 2.3. Accessing the buildConnectionString Function's doc string
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    >>> import odbchelper                              (1)
    >>> params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}
    >>> print odbchelper.buildConnectionString(params) (2)
    server=mpilgrim;uid=sa;database=master;pwd=secret
    >>> print odbchelper.buildConnectionString.__doc__ (3)
    Build a connection string from a dictionary
    
    Returns string.



(1) The first line imports the odbchelper program as a module -- a chunk of
    code that you can use interactively, or from a larger Python program.
    (You'll see examples of multi-module Python programs in Chapter 4.) Once
    you import a module, you can reference any of its public functions,
    classes, or attributes. Modules can do this to access functionality in
    other modules, and you can do it in the IDE too. This is an important
    concept, and you'll talk more about it later.
(2) When you want to use functions defined in imported modules, you need to
    include the module name. So you can't just say buildConnectionString; it
    must be odbchelper.buildConnectionString. If you've used classes in Java,
    this should feel vaguely familiar.
(3) Instead of calling the function as you would expect to, you asked for one
    of the function's attributes, __doc__.

    Note: Python vs. Perl: import
    import in Python is like require in Perl. Once you import a Python module,
    you access its functions with module.function; once you require a Perl
    module, you access its functions with module::function.

2.4.1. The Import Search Path
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Before you go any further, I want to briefly mention the library search path.
Python looks in several places when you try to import a module. Specifically,
it looks in all the directories defined in sys.path. This is just a list, and
you can easily view it or modify it with standard list methods. (You'll learn
more about lists later in this chapter.)


Example 2.4. Import Search Path
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,



.. sourcecode:: python

    >>> import sys                 (1)
    >>> sys.path                   (2)
    ['', '/usr/local/lib/python2.2', '/usr/local/lib/python2.2/plat-linux2', 
    '/usr/local/lib/python2.2/lib-dynload', '/usr/local/lib/python2.2/site-packages', 
    '/usr/local/lib/python2.2/site-packages/PIL', '/usr/local/lib/python2.2/site-packages/piddle']
    >>> sys                        (3)
    <module 'sys' (built-in)>
    >>> sys.path.append('/my/new/path') (4)



(1) Importing the sys module makes all of its functions and attributes
    available.
(2) sys.path is a list of directory names that constitute the current search
    path. (Yours will look different, depending on your operating system, what
    version of Python you're running, and where it was originally installed.)
    Python will look through these directories (in this order) for a .py file
    matching the module name you're trying to import.
(3) Actually, I lied; the truth is more complicated than that, because not all
    modules are stored as .py files. Some, like the sys module, are "built-in
    modules"; they are actually baked right into Python itself. Built-in
    modules behave just like regular modules, but their Python source code is
    not available, because they are not written in Python! (The sys module is
    written in C.)
(4) You can add a new directory to Python's search path at runtime by appending
    the directory name to sys.path, and then Python will look in that directory
    as well, whenever you try to import a module. The effect lasts as long as
    Python is running. (You'll talk more about append and other list methods in
    Chapter 3.)

2.4.2. What's an Object?
~~~~~~~~~~~~~~~~~~~~~~~~~



Everything in Python is an object, and almost everything has attributes and
methods. All functions have a built-in attribute __doc__, which returns the doc
string defined in the function's source code. The sys module is an object which
has (among other things) an attribute called path. And so forth.

Still, this begs the question. What is an object? Different programming
languages define "object" in different ways. In some, it means that all objects
must have attributes and methods; in others, it means that all objects are
subclassable. In Python, the definition is looser; some objects have neither
attributes nor methods (more on this in Chapter 3), and not all objects are
subclassable (more on this in Chapter 5). But everything is an object in the
sense that it can be assigned to a variable or passed as an argument to a
function (more in this in Chapter 4).

This is so important that I'm going to repeat it in case you missed it the
first few times: everything in Python is an object. Strings are objects. Lists
are objects. Functions are objects. Even modules are objects.

Further Reading on Objects
   
  * Python Reference Manual (http://www.python.org/doc/current/ref/) explains
    exactly what it means to say that everything in Python is an object (http:/
    /www.python.org/doc/current/ref/objects.html), because some people are
    pedantic and like to discuss this sort of thing at great length.
  * eff-bot (http://www.effbot.org/guides/) summarizes Python objects (http:/
    /www.effbot.org/guides/python-objects.htm).

2.5. Indenting Code
--------------------



Python functions have no explicit begin or end, and no curly braces to mark
where the function code starts and stops. The only delimiter is a colon (:) and
the indentation of the code itself.


Example 2.5. Indenting the buildConnectionString Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def buildConnectionString(params):
        """Build a connection string from a dictionary of parameters.
    
        Returns string."""
        return ";".join(["%s=%s" % (k, v) for k, v in params.items()])



Code blocks are defined by their indentation. By "code block", I mean
functions, if statements, for loops, while loops, and so forth. Indenting
starts a block and unindenting ends it. There are no explicit braces, brackets,
or keywords. This means that whitespace is significant, and must be consistent.
In this example, the function code (including the doc string) is indented four
spaces. It doesn't need to be four spaces, it just needs to be consistent. The
first line that is not indented is outside the function.

Example 2.6, ??if Statements?? shows an example of code indentation with if
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

statements.


Example 2.6. if Statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. sourcecode:: python

    def fib(n):                   (1)
        print 'n =', n            (2)
        if n > 1:                 (3)
            return n * fib(n - 1)
        else:                     (4)
            print 'end of the line'
            return 1



(1) This is a function named fib that takes one argument, n. All the code
    within the function is indented.
(2) Printing to the screen is very easy in Python, just use print. print
    statements can take any data type, including strings, integers, and other
    native types like dictionaries and lists that you'll learn about in the
    next chapter. You can even mix and match to print several things on one
    line by using a comma-separated list of values. Each value is printed on
    the same line, separated by spaces (the commas don't print). So when fib is
    called with 5, this will print "n = 5".
(3) if statements are a type of code block. If the if expression evaluates to
    true, the indented block is executed, otherwise it falls to the else block.
(4) Of course if and else blocks can contain multiple lines, as long as they
    are all indented the same amount. This else block has two lines of code in
    it. There is no other special syntax for multi-line code blocks. Just
    indent and get on with your life.


After some initial protests and several snide analogies to Fortran, you will
make peace with this and start seeing its benefits. One major benefit is that
all Python programs look similar, since indentation is a language requirement
and not a matter of style. This makes it easier to read and understand other
people's Python code.
   
    Note: Python vs. Java: Separating Statements
    Python uses carriage returns to separate statements and a colon and
    indentation to separate code blocks. C++ and Java use semicolons to
    separate statements and curly braces to separate code blocks.


Further Reading on Code Indentation
   
  * Python Reference Manual (http://www.python.org/doc/current/ref/)
    discusses cross-platform indentation issues and shows various indentation
    errors (http://www.python.org/doc/current/ref/indentation.html).
  * Python Style Guide (http://www.python.org/doc/essays/styleguide.html)
    discusses good indentation style.

2.6. Testing Modules
---------------------



Python modules are objects and have several useful attributes. You can use this
to easily test your modules as you write them. Here's an example that uses the
if __name__ trick.


::

    if __name__ == "__main__":
    
Some quick observations before you get to the good stuff. First, parentheses


are not required around the if expression. Second, the if statement ends with a
colon, and is followed by indented code.
   
    Note: Python vs. C: Comparison and Assignment
    Like C, Python uses == for comparison and = for assignment. Unlike C,
    Python does not support in-line assignment, so there's no chance of
    accidentally assigning the value you thought you were comparing.


So why is this particular if statement a trick? Modules are objects, and all
modules have a built-in attribute __name__. A module's __name__ depends on how
you're using the module. If you import the module, then __name__ is the
module's filename, without a directory path or file extension. But you can also
run the module directly as a standalone program, in which case __name__ will be
a special default value, __main__.


::

    >>> import odbchelper
    >>> odbchelper.__name__
    'odbchelper'



Knowing this, you can design a test suite for your module within the module
itself by putting it in this if statement. When you run the module directly,
__name__ is __main__, so the test suite executes. When you import the module,
__name__ is something else, so the test suite is ignored. This makes it easier
to develop and debug new modules before integrating them into a larger program.
   
    Tip: if __name__ on Mac OS
    On MacPython, there is an additional step to make the if __name__ trick
    work. Pop up the module's options menu by clicking the black triangle in
    the upper-right corner of the window, and make sure Run as __main__ is
    checked.


Further Reading on Importing Modules
   
  * Python Reference Manual (http://www.python.org/doc/current/ref/)
    discusses the low-level details of importing modules (http://www.python.org
    /doc/current/ref/import.html).

